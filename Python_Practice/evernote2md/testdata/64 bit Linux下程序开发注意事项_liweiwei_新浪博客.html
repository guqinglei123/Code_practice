<div><span style="font-weight: 300;">64 bit Linux下程序开发注意事项</span>&nbsp;
<div>64 位的优点：64 位的应用程序可以直接访问 4EB 的内存和文件大小最大达到4 EB（2 的 63 次幂）；可以访问大型数据库。本文介绍的是64位下C语言开发程序注意事项。<br/></div></div><div><span style="font-weight: bold;">1 32 位和 64 位C数据类型</span></div><div>32和64位C语言内置数据类型，如下表所示。</div><div><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=57421ff80100c7g1&amp;url=http://s16.sinaimg.cn/orignal/57421ff8h6286c10998af" style="text-decoration: none;" target="_blank"><en-media hash="6c1ad300cc250cd39ad7d800920d9c8a" height="280" style="margin:0px;padding:0px;border:0px;list-style:none;" title="64 &lt;wbr&gt;bit &lt;wbr&gt;Linux下程序开发注意事项" type="image/jpeg" width="452"/></a></div><div>上表中第一行的大写字母和数字含义如下所示：</div><div>I表示：int类型</div><div>L表示：long类型</div><div>P表示：pointer指针类型</div><div>32表示：32位系统</div><div>64表示64位系统</div><div>如：LP64表示，在64位系统下的long类型和pointer类型长度为64位。</div><div>64位Linux 使用了 LP64 标准，即：long类型和pointer类型长度为64位，其他类型的长度和32位系统下相同类型的长度相同，32位和64位下类型的长度比较见上图的蓝色部分。</div><div>下图为在32和64位linux系统下使用sizeof检测出的数据类型的长度。</div><div>32位平台下结果：</div><div align="center"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=57421ff80100c7g1&amp;url=http://s12.sinaimg.cn/orignal/57421ff8h6286cb85a1eb" style="text-decoration: none;" target="_blank"><en-media hash="53217a2a8dd1ac66db8b199f00622b97" height="106" style="margin:0px;padding:0px;border:0px;list-style:none;" title="64 &lt;wbr&gt;bit &lt;wbr&gt;Linux下程序开发注意事项" type="image/jpeg" width="458"/></a></div><div>64位平台下结果：</div><div align="center"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=57421ff80100c7g1&amp;url=http://s12.sinaimg.cn/orignal/57421ff8h6286cfa89b8b" style="text-decoration: none;" target="_blank"><en-media hash="02fddcd3afcc0d9e4e20b4a9b6bd4683" height="109" style="margin:0px;padding:0px;border:0px;list-style:none;" title="64 &lt;wbr&gt;bit &lt;wbr&gt;Linux下程序开发注意事项" type="image/jpeg" width="490"/></a></div><div><span style="font-weight: bold;">2 64系统下开发注意事项</span></div><div><b>2.1 格式化字符串：long使用%ld，指针使用%p，例如：</b></div><div>char *ptr = &amp;something;</div><div>printf (%x\n&quot;, ptr);</div><div>上面的代码在 64 位系统上不正确，只显示低 4 字节的内容。正确的方法是：使用 %p。</div><div>char *ptr = &amp;something;</div><div>printf (%p\n&quot;, ptr);</div><div><b>2.2 数字常量：常量要加L</b></div><div>例1，常数 0xFFFFFFFF 是一个有符号的 long 类型。在 32 位系统上，这会将所有位都置位（每位全为 1），但是在 64 位系统上，只有低 32 位被置位了，结果是这个值是 0x00000000FFFFFFFF。</div><div>例2，在下面的代码中，a 的最大值可以是 31。这是因为 1 &lt;&lt; a 是 int 类型的。</div><div>long l = 1 &lt;&lt; a;</div><div>要在 64 位系统上进行位移，应使用 1L，如下所示：</div><div>long l = 1L &lt;&lt; a;</div><div><b>2.3 符号扩展：避免有符号数与无符号数运算，例如：</b></div><div>int i = -2;</div><div>unsigned int j = 1;</div><div>long l = i + j;</div><div>printf(&quot;Answer: %ld\n&quot;,l);</div><div>32位下是-1，在64位下是4294967295。原因在于表达式(i+j)是一个unsigned int</div><div>表达式，但把它赋值给k时，符号位没有被扩展。要解决这个问题，两端的操作数只要均为signed或均为unsigned就可。</div><div><b>2.4 转换截断</b></div><div>转换截断发生在把long转换成int时，如下例：</div><div>int length = (int) strlen(str);</div><div>strlen返回size_t（它在LP64中是unsigned long），当赋值给一个int时，截断是必然发生的。而通常，截断只会在str的长度大于2GB时才会发生，这种情况在程序中一般不会出现。虽然如此，也应该尽量使用适当的多态类型（如size_t、uintptr_t等等）。</div><div><b>2.5 赋值，</b></div><div>不要交换使用 int 和 long 类型，例如：</div><div>int i;</div><div>time_t l;</div><div>i = l;</div><div>不要使用 int 类型来存储指针，例如：</div><div>unsigned int i, *ptr;</div><div>i = (unsigned) ptr;</div><div>不要使用指针来存放 int 类型的值。例如：</div><div>int *ptr;</div><div>int i;</div><div>ptr = (int *) i;</div><div><b>2.6 移植倒64位环境下的性能</b></div><div>移植到64位平台后，性能实际上降低了。原因是64位中的指针长度和数据大小有关，并由此引发的缓存命中率降低、数据对齐等问题。通过改变结构中数据排列的先后顺序，会因为少了填充数据，存储空间也随之减少。如：</div><div align="center"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=57421ff80100c7g1&amp;url=http://s10.sinaimg.cn/orignal/57421ff8h6286d3a329a9" style="text-decoration: none;" target="_blank"><en-media hash="92a7af58bc532656f85a26be60361da4" height="122" style="margin:0px;padding:0px;border:0px;list-style:none;" title="64 &lt;wbr&gt;bit &lt;wbr&gt;Linux下程序开发注意事项" type="image/jpeg" width="490"/></a></div><div><b>2.7 程序中链接到的库要使用64位的库。</b></div><div>由上可见所有的问题都是由long和指针长度改变引起，在开发过程中只有牢记long和指针类型的长度。</div><div><br/></div><div style="clear:both;height:0px;overflow:hidden;"/><div><br/></div>