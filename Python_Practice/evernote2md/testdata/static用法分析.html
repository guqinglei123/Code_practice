<div><font style="font-size: 14pt;"><span style="font-weight: bold;">来源网址：</span> <a href="http://www.cnblogs.com/stoneJin/archive/2011/09/21/2183313.html">http://www.cnblogs.com/stoneJin/archive/2011/09/21/2183313.html</a></font></div><div><a href="http://www.cnblogs.com/lzjsky/archive/2011/01/24/1943199.html"><font style="font-size: 14pt;">http://www.cnblogs.com/lzjsky/archive/2011/01/24/1943199.html</font></a></div><div><font style="font-size: 14pt;"><a href="http://blog.csdn.net/jshayzf/article/details/8108221">http://blog.csdn.net/jshayzf/article/details/8108221</a><br/></font></div><div style="-evernote-webclip:true;"><div><font style="font-size: 14pt;"><a href="http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html">http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html</a><span>&nbsp;&nbsp; &nbsp;</span></font></div><div><span><b><font style="font-size: 14pt;">1.C语言中的静态成员</font></b></span></div><div style="text-align: left;"><font style="font-size: 14pt;"><b>1.1 第一条作用：隐藏，即</b><b><span style="-evernote-webclip:true;-en-paragraph:true;">在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</span></b></font></div><div style="text-align: left;"><font style="font-size: 14pt;"><span style="-evernote-webclip:true;-en-paragraph:true;">注意，只有在定义了变量后才能使用。如果变量定义在使用之后，要用extern 声明。所以，一般全部变量都会在文件的最开始处定义<b>。</b></span>当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。为理解这句话，我举例来说明。我们要同时编译两个源文件，一个是a.c，另一个是main.c</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">//下面是a.c的内容</font></div><div><font style="font-size: 14pt;">char a = &apos;A&apos;; // global variable</font></div><div><font style="font-size: 14pt;">void msg()</font></div><div><font style="font-size: 14pt;">{</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;printf(&quot;Hello\n&quot;);</font></div><div><font style="font-size: 14pt;">}</font></div><div><font style="font-size: 14pt;">//下面是main.c的内容</font></div><div><font style="font-size: 14pt;">int main(void)</font></div><div><font style="font-size: 14pt;">{&nbsp;&nbsp;&nbsp;&nbsp;</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;extern char a;&nbsp;&nbsp;&nbsp;&nbsp;// extern variable must be declared before use</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;printf(&quot;%c &quot;, a);</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;(void)msg();</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;return 0;</font></div><div><font style="font-size: 14pt;">}</font></div></div><div><font style="font-size: 14pt;">程序的运行结果是：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">A Hello</font></div></div><div style="text-align: left;"><font style="font-size: 14pt;">你可能会问：为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。</font></div><div><b><font style="font-size: 14pt;"><br/></font></b></div><div><font style="font-size: 14pt;"><b>1.2 static的第二个作用是</b><span style="font-weight: bold;-evernote-webclip:true;">若该变量没有初始化，将</span><span style="font-weight: bold;-evernote-webclip:true;">默认初始化为0；若</span><span style="font-weight: bold;-evernote-webclip:true;">该变量进行初始化，则</span><b>保持变量内容的持久</b><span style="font-weight: bold;-evernote-webclip:true;">。即</span><b>在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持其值不变（该变量存放在静态变量区）。</b></font></div><div><font style="font-size: 14pt;">存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来。static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">#include &lt;stdio.h&gt;</font></div><div><font style="font-size: 14pt;">int fun(void){</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;static int count = 10;&nbsp;&nbsp;&nbsp;&nbsp;// 事实上此赋值语句从来没有执行过</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;return count--;</font></div><div><font style="font-size: 14pt;">}</font></div><div><font style="font-size: 14pt;">int count = 1;</font></div><div><font style="font-size: 14pt;">int main(void)</font></div><div><font style="font-size: 14pt;">{&nbsp;&nbsp;&nbsp;&nbsp;</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;printf(&quot;global\t\tlocal static\n&quot;);</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;for(; count &lt;= 10; ++count)</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d\t\t%d\n&quot;, count, fun());&nbsp;&nbsp;&nbsp;&nbsp;</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;return 0;</font></div><div><font style="font-size: 14pt;">}</font></div></div><div><font style="font-size: 14pt;">程序的运行结果是：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">global&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local static</font></div><div><font style="font-size: 14pt;">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</font></div><div><font style="font-size: 14pt;">2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9</font></div><div><font style="font-size: 14pt;">3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8</font></div><div><font style="font-size: 14pt;">4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7</font></div><div><font style="font-size: 14pt;">5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6</font></div><div><font style="font-size: 14pt;">6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</font></div><div><font style="font-size: 14pt;">7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4</font></div><div><font style="font-size: 14pt;">8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3</font></div><div><font style="font-size: 14pt;">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</font></div><div><font style="font-size: 14pt;">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</font></div></div><div><font style="font-size: 14pt;">其实全局变量还具备<span style="-evernote-webclip:true;">默认初始化为0</span>这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。不妨做个小实验验证一下。<br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">#include &lt;stdio.h&gt;</font></div><div><font style="font-size: 14pt;">int a;</font></div><div><font style="font-size: 14pt;">int main(void)</font></div><div><font style="font-size: 14pt;">{</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;int i;</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;static char str[10];</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;printf(&quot;integer: %d;&nbsp;&nbsp;string: (begin)%s(end)&quot;, a, str);</font></div><div><font style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;return 0;</font></div><div><font style="font-size: 14pt;">}</font></div></div><div><font style="font-size: 14pt;">程序的运行结果如下</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">integer: 0; string: (begin)(end)</font></div></div><div style="text-align: left;"><font style="font-size: 14pt;"><span style="font-weight: bold;-evernote-webclip:true;">1.3</span><span style="font-weight: bold;-en-paragraph:true;-evernote-webclip:true;">在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</span><br/></font></div><div style="text-align: left;"><font style="font-size: 14pt;"><br/></font></div><div style="text-align: left;"><font style="font-size: 14pt;"><b>2.类中的静态成员</b><br/></font></div><div><font style="font-size: 14pt;">&nbsp; &nbsp; &nbsp; 类中的静态成员真是个让人爱恨交加的特性。我决定好好总结一下静态类成员的知识点，以便自己在以后面试中，在此类问题上不在被动。<br/></font></div><div><font style="font-size: 14pt;">静态类成员包括静态数据成员和静态函数成员两部分。</font></div><div><b><font style="font-size: 14pt;">2.1 静态数据成员：</font></b></div><div><font style="font-size: 14pt;">&nbsp; &nbsp; &nbsp; 类体中的数据成员的声明前加上static关键字，该数据成员就成为了该类的静态数据成员。和其他数据成员一样，静态数据成员也遵守public/protected/private访问规则。同时，静态数据成员还具有以下特点：</font></div><div><b><font style="font-size: 14pt;">2.1.1 静态数据成员的定义。</font></b></div><div><font style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span>静态数据成员实际上是类域中的全局变量。所以，静态数据成员的定义(初始化)不应该被放在头文件中。其定义方式与全局变量相同。举例如下：<br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">xxx.h文件</font></div><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">private:</font></div><div><font style="font-size: 14pt;">static const int _i;//声明，标准c++支持有序类型在类体中初始化,但vc6不支持。</font></div><div><font style="font-size: 14pt;">};</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">xxx.cpp文件</font></div><div><font style="font-size: 14pt;">const int base::_i=10;//定义(初始化)时不受private和protected访问限制.</font></div></div><div><font style="font-size: 14pt;"><font style="color: rgb(158, 0, 243);">注：不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。</font><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><b><font style="font-size: 14pt;">2.1.2 静态数据成员被类的所有对象所共享，包括该类派生类的对象。即派生类对象与基类对象共享基类的静态数据成员。</font></b></div><div><font style="font-size: 14pt;">举例如下：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">public :</font></div><div><font style="font-size: 14pt;">static int _num;//声明</font></div><div><font style="font-size: 14pt;">};</font></div><div><font style="font-size: 14pt;">int base::_num=0;//静态数据成员的真正定义</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">class derived:public base{</font></div><div><font style="font-size: 14pt;">};</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">main()</font></div><div><font style="font-size: 14pt;">{</font></div><div><font style="font-size: 14pt;">base a;</font></div><div><font style="font-size: 14pt;">derived b;</font></div><div><font style="font-size: 14pt;">a._num++;</font></div><div><font style="font-size: 14pt;">cout&lt;&lt;&quot;base class static data number _num is&quot;&lt;&lt;a._num&lt;&lt;endl;</font></div><div><font style="font-size: 14pt;">b._num++;</font></div><div><font style="font-size: 14pt;">cout&lt;&lt;&quot;derived class static data number _num is&quot;&lt;&lt;b._num&lt;&lt;endl;</font></div><div><font style="font-size: 14pt;">}// 结果为1,2;可见派生类与基类共用一个静态数据成员。</font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><b><font style="font-size: 14pt;">2.1.3 静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。</font></b></div><div><font style="font-size: 14pt;">举例如下：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">public :</font></div><div><font style="font-size: 14pt;">static int _staticVar;</font></div><div><font style="font-size: 14pt;">int _var;</font></div><div><font style="font-size: 14pt;">void foo1(int i=_staticVar);//正确,_staticVar为静态数据成员</font></div><div><font style="font-size: 14pt;">void foo2(int i=_var);//错误,_var为普通数据成员</font></div><div><font style="font-size: 14pt;">};</font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><b><font style="font-size: 14pt;">2.1.4 静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的 指针或引用。</font></b></div><div><font style="font-size: 14pt;">举例如下：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">public :</font></div><div><font style="font-size: 14pt;">static base _object1;//正确，静态数据成员</font></div><div><font style="font-size: 14pt;">base _object2;//错误</font></div><div><font style="font-size: 14pt;">base *pObject;//正确，指针</font></div><div><font style="font-size: 14pt;">base &amp;mObject;//正确，引用</font></div><div><font style="font-size: 14pt;">};</font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><b><font style="font-size: 14pt;">2.1.5.<span style="-evernote-webclip:true;">静态数据成员的值在const成员函数中可以被合法的改变</span></font></b></div><div><font style="font-size: 14pt;">这个特性，我不知道是属于标准c++中的特性，还是vc6自己的特性。举例如下：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">public:</font></div><div><font style="font-size: 14pt;">base(){_i=0;_val=0;}</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">mutable int _i;</font></div><div><font style="font-size: 14pt;">static int _staticVal;</font></div><div><font style="font-size: 14pt;">int _val;</font></div><div><font style="font-size: 14pt;">void test() const{//const 成员函数</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">_i++;//正确，mutable数据成员</font></div><div><font style="font-size: 14pt;">_staticVal++;//正确，static数据成员</font></div><div><font style="font-size: 14pt;">_val++;//错误</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">}</font></div><div><font style="font-size: 14pt;">};</font></div><div><font style="font-size: 14pt;">int base::_staticVal=0;</font></div></div><div><font style="font-size: 14pt;"><b>2.2 静态成员函数</b><br/></font></div><div><font style="font-size: 14pt;"><b>2.2.1.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用 类成员函数指针来储存。</b><br/></font></div><div><font style="font-size: 14pt;">举例如下：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">static int func1();</font></div><div><font style="font-size: 14pt;">int func2();</font></div><div><font style="font-size: 14pt;">};</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">int (*pf1)()=&amp;base::func1;//普通的函数指针</font></div><div><font style="font-size: 14pt;">int (base::*pf2)()=&amp;base::func2;//成员函数指针</font></div></div><div><font style="font-size: 14pt;"><span style="font-weight: bold;-evernote-webclip:true;">2.2.</span><b>2 静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。</b><br/></font></div><div><font style="font-size: 14pt;"><span style="font-weight: bold;-evernote-webclip:true;">2.2.</span><b>3 静态成员函数不可以同时声明为 virtual、const、volatile函数。</b></font></div><div><font style="font-size: 14pt;">举例如下：</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">class base{</font></div><div><font style="font-size: 14pt;">virtual static void func1();//错误</font></div><div><font style="font-size: 14pt;">static void func2() const;//错误</font></div><div><font style="font-size: 14pt;">static void func3() volatile;//错误</font></div><div><font style="font-size: 14pt;">};</font></div></div><div><font style="font-size: 14pt;"><b>2.2.4 静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</b><br/></font></div><div style="clear:both;"/><div><font style="font-size: 14pt;"><br/></font></div></div><div style="-evernote-webclip:true;"><div><b><font style="font-size: 14pt;">3.相关问题</font></b></div><div align="left"><span style="font-weight: bold;"><font style="font-size: 14pt;">问题1. static全局变量与普通的全局变量有什么区别 ?</font></span></div><div><font style="font-size: 14pt;"><span style="font-weight: bold;">　</span>　全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的<font style="color: rgb(235, 0, 115);">作用域（自己注：修改为可链接性）</font>是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。<span style="color: rgb(158, 0, 243);">s</span><span style="color: rgb(158, 0, 243);">t</span><span style="color: rgb(158, 0, 243);">atic全局变量只初始化一次，防止在其他文件单元中被引用。</span></font></div><div><span style="color: rgb(158, 0, 243);"><font style="font-size: 14pt;"><br/></font></span></div><div><font style="font-size: 14pt;"><span style="font-weight: bold;-evernote-webclip:true;">问题</span><span style="font-weight: bold;">2.&nbsp; static局部变量和普通局部变量有什么区别 ？</span></font></div><div><font style="font-size: 14pt;">　　把局部变量改变为静态变量后是改变了它的存储方式即改变了它的<span style="font-weight: bold;">生存期</span>。把全局变量改变为静态变量后是改变了它的<span style="font-weight: bold;">作用域</span>，限制了它的使用范围。<font style="color: rgb(158, 0, 243);">static局部变量只被初始化一次，下一次依据上一次结果值。</font></font></div><div><font style="color: rgb(158, 0, 243); font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-weight: bold;-evernote-webclip:true;">问题</span><span style="font-weight: bold;">3.&nbsp; static函数与普通函数有什么区别？</span></font></div><div><font style="font-size: 14pt;">　　 static函数与普通函数<font style="color: rgb(235, 0, 115);">作用域<span style="-evernote-webclip:true;">（</span></font><span style="color: rgb(235, 0, 115);-evernote-webclip:true;">自己注：修改为可链接性）</span>不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。<font style="color: rgb(158, 0, 243);">static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</font></font></div><div><font style="color: rgb(158, 0, 243); font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-weight: bold;-evernote-webclip:true;">问题</span><b>4.为什么在<a href="http://lib.csdn.net/base/linux" style="text-decoration-line: none;" title="Linux知识库">Linux</a>的模块编程中，所有的函数和全局变量都要用static关键字声明？</b></font></div><div><font style="font-size: 14pt;">&nbsp; &nbsp; &nbsp; &nbsp;在<a href="http://lib.csdn.net/base/embeddeddevelopment" style="font-weight: bold; text-decoration-line: none;" target="_blank" title="嵌入式开发知识库">嵌入式</a>系统中，要时刻懂得移植的重要性，程序可能是很多程序员共同协作同时完成，在定义变量及函数的过程，可能会重名，这给系统的集成带来麻烦，因此保证不冲突的办法是显示的表示此变量或者函数是本地的，static即可。在<a href="http://lib.csdn.net/base/linux" style="font-weight: bold; text-decoration-line: none;" target="_blank" title="Linux知识库">Linux</a>的模块编程中，这一条很明显，所有的函数和全局变量都要用static关键字声明，将其作用域限制在本模块内部，与其他模块共享的函数或者变量要EXPORT到内核中。<br/></font></div></div><div style="-evernote-webclip:true;"><div style="-en-paragraph:true;"/><div style="-en-paragraph:true;"><div><span style="font-style: normal;"><b><font style="font-size: 14pt;"><br/></font></b></span></div><div><span style="font-style: normal;"><b><font style="font-size: 14pt;">5.总结</font></b></span></div><div><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">static关键字至少有下列n个作用：</font></span></div><div><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">（1）设置变量的存储域，函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</font></span></div></div><div style="-en-paragraph:true;"><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">（2）限制变量的作用域，在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</font></span></div><div style="-en-paragraph:true;"><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">（3）限制函数的作用域，在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</font></span></div><div style="-en-paragraph:true;"><div><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">以下是C++对static的扩展</font></span></div><div><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">（4）在类中的static成员变量意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；</font></span></div><div><span style="font-style: normal; font-weight: normal;"><font style="font-size: 14pt;">（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</font></span></div></div><div><font style="font-size: 14pt;">.</font></div></div><div><br/></div>