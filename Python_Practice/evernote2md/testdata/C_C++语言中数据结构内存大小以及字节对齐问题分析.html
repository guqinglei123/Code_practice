<div><span style="font-weight: bold;">来源网址：</span> <a href="http://www.cnblogs.com/clover-toeic/p/3853132.html">http://www.cnblogs.com/clover-toeic/p/3853132.html</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="http://www.cnblogs.com/ylhome/archive/2010/07/10/1774770.html">http://www.cnblogs.com/ylhome/archive/2010/07/10/1774770.html</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="http://www.cnblogs.com/-zhangnian/p/6422559.html">http://www.cnblogs.com/-zhangnian/p/6422559.html</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="https://www.cnblogs.com/embedded-linux/p/5801999.html">https://www.cnblogs.com/embedded-linux/p/5801999.html</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="https://www.cnblogs.com/xidongs/p/5655440.html">https://www.cnblogs.com/xidongs/p/5655440.html</a>&nbsp;</div><div><span style="font-weight: bold;">来源网址：</span> <a href="https://blog.csdn.net/apollon_krj/article/details/52705902">https://blog.csdn.net/apollon_krj/article/details/52705902</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="https://blog.csdn.net/tianshuai1111/article/details/7576279">https://blog.csdn.net/tianshuai1111/article/details/7576279</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="http://www.voidcn.com/article/p-bzfzapcx-bcn.html">http://www.voidcn.com/article/p-bzfzapcx-bcn.html</a></div><div><span style="font-weight: bold;">来源网址：</span> <a href="https://blog.csdn.net/gen_ye/article/details/52694920">https://blog.csdn.net/gen_ye/article/details/52694920</a></div><div><br/></div><div style="margin:0px;padding:0px;clear:both;"/><div><div>&nbsp; &nbsp;</div><h1><span style="font-weight: bold;">引言</span></h1><div>&nbsp; &nbsp; &nbsp;考虑下面的结构体定义：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1 typedef struct{</div><div>2 char c1;</div><div>3 short s;</div><div>4 char c2;</div><div>5 int i;</div><div>6 }T_FOO;</div><div><br/></div><div><br/></div></div><div><br/></div><div>&nbsp; &nbsp; &nbsp;假设这个结构体的成员在内存中是紧凑排列的，且c1的起始地址是0，则s的地址就是1，c2的地址是3，i的地址是4。</div><div>&nbsp; &nbsp; &nbsp;现在，我们编写一个简单的程序：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1 int main(void){</div><div>2 T_FOO a;</div><div>3 printf(&quot;c1 -&gt; %d, s -&gt; %d, c2 -&gt; %d, i -&gt; %d\n&quot;,</div><div>4 (unsigned int)(void*)&amp;a.c1 - (unsigned int)(void*)&amp;a,</div><div>5 (unsigned int)(void*)&amp;a.s - (unsigned int)(void*)&amp;a,</div><div>6 (unsigned int)(void*)&amp;a.c2 - (unsigned int)(void*)&amp;a,</div><div>7 (unsigned int)(void*)&amp;a.i - (unsigned int)(void*)&amp;a);</div><div>8 return 0;</div><div>9 }</div><div><br/></div><div><br/></div></div><div><br/></div><div>&nbsp; &nbsp; &nbsp;运行后输出：</div><div>1 c1 -&gt; 0, s -&gt; 2, c2 -&gt; 4, i -&gt; 8</div><div>&nbsp; &nbsp; &nbsp;为什么会这样？这就是字节对齐导致的问题。</div><div>&nbsp; &nbsp; &nbsp;本文在参考诸多资料的基础上，详细介绍常见的字节对齐问题。因成文较早，资料来源大多已不可考，敬请谅解。</div><h1><span style="font-weight: bold;">一 &nbsp;什么是字节对齐</span></h1><div>&nbsp; &nbsp; &nbsp;现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</div><h1><span style="font-weight: bold;">二 &nbsp;对齐的原因和作用</span></h1><div>&nbsp; &nbsp; &nbsp;不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。</div><div>&nbsp; &nbsp; &nbsp;但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。</div><div>&nbsp; &nbsp; &nbsp;因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。</div><div>&nbsp; &nbsp; &nbsp;此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。</div><div>&nbsp;</div><h1><span style="font-weight: bold;">三 &nbsp;对齐的分类和准则</span></h1><div>&nbsp; &nbsp; &nbsp;主要基于Intel X86架构介绍结构体对齐和栈内存对齐，位域本质上为结构体类型。</div><div>&nbsp; &nbsp; &nbsp;对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。</div><h2><span style="font-weight: bold;">3.1 结构体对齐</span></h2><div>&nbsp; &nbsp; &nbsp;在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</div><div>&nbsp; &nbsp; &nbsp;字节对齐的问题主要就是针对结构体。</div><h3><span style="font-weight: bold;">3.1.1 简单示例</span></h3><div>&nbsp; &nbsp; &nbsp;先看个简单的例子(32位，X86处理器，GCC编译器)：</div><div>&nbsp; &nbsp; 【例1】设结构体如下定义：</div><div><br/></div><div>1 struct A{</div><div>2 int a;</div><div>3 char b;</div><div>4 short c;</div><div>5 };</div><div>6 struct B{</div><div>7 char b;</div><div>8 int a;</div><div>9 short c;</div><div>10 };</div><div><br/></div><div>&nbsp; &nbsp; &nbsp;已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？</div><div>&nbsp; &nbsp; &nbsp;结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。</div><div>&nbsp; &nbsp; &nbsp;结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。</div><h3><span style="font-weight: bold;">3.1.2 对齐准则</span></h3><div>&nbsp; &nbsp; &nbsp;先来看四个重要的基本概念：</div><div>&nbsp; &nbsp; &nbsp;1) 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。</div><div>&nbsp; &nbsp; &nbsp;2) 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。</div><div>&nbsp; &nbsp; &nbsp;3) 指定对齐值：#pragma pack (value)时的指定对齐值value。</div><div>&nbsp; &nbsp; &nbsp;4) 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。</div><div>&nbsp; &nbsp; &nbsp;基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。</div><div>&nbsp; &nbsp; &nbsp;其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。</div><div>&nbsp; &nbsp; &nbsp;以此分析3.1.1节中的结构体B：</div><div>&nbsp; &nbsp; &nbsp;假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。</div><div>&nbsp; &nbsp; &nbsp;再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节，sizeof(struct B)=12。</div><div>&nbsp; &nbsp; &nbsp;之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。</div><div align="left">&nbsp; &nbsp; &nbsp;上面的概念非常便于理解，不过个人还是更喜欢下面的对齐准则。</div><div align="left">&nbsp; &nbsp; &nbsp;结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：</div><div align="left">&nbsp; &nbsp; &nbsp;1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</div><div align="left">&nbsp; &nbsp; &nbsp;2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</div><div align="left">&nbsp; &nbsp; &nbsp;3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</div><div align="left">&nbsp; &nbsp; &nbsp;对于以上规则的说明如下：</div><div align="left">&nbsp; &nbsp; &nbsp;第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</div><div align="left">&nbsp; &nbsp; &nbsp;第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</div><div align="left">&nbsp; &nbsp; &nbsp;第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</div><div>&nbsp; &nbsp; 【例2】假设4字节对齐，以下程序的输出结果是多少？</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 /* OFFSET宏定义可取得指定结构体某成员在结构体内部的偏移 */</div><div>2 #define OFFSET(st, field) (size_t)&amp;(((st*)0)-&gt;field)</div><div>3 typedef struct{</div><div>4 char a;</div><div>5 short b;</div><div>6 char c;</div><div>7 int d;</div><div>8 char e[3];</div><div>9 }T_Test;</div><div>10</div><div>11 int main(void){</div><div>12 printf(&quot;Size = %d\n a-%d, b-%d, c-%d, d-%d\n e[0]-%d, e[1]-%d, e[2]-%d\n&quot;,</div><div>13 sizeof(T_Test), OFFSET(T_Test, a), OFFSET(T_Test, b),</div><div>14 OFFSET(T_Test, c), OFFSET(T_Test, d), OFFSET(T_Test, e[0]),</div><div>15 OFFSET(T_Test, e[1]),OFFSET(T_Test, e[2]));</div><div>16 return 0;</div><div>17 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;执行后输出如下：</div><div>1 Size = 16</div><div>2 a-0, b-2, c-4, d-8</div><div>3 e<span style="font-weight: bold;">[</span>0<span style="font-weight: bold;">]</span>-12, e<span style="font-weight: bold;">[</span>1<span style="font-weight: bold;">]</span>-13, e<span style="font-weight: bold;">[</span>2<span style="font-weight: bold;">]</span>-14</div><div>&nbsp; &nbsp; &nbsp;下面来具体分析：</div><div>&nbsp; &nbsp; &nbsp;首先char a占用1个字节，没问题。</div><div>&nbsp; &nbsp; &nbsp;short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。</div><div>&nbsp; &nbsp; &nbsp;char c占用1个字节，没问题。</div><div>&nbsp; &nbsp; &nbsp;int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。</div><div>&nbsp; &nbsp; &nbsp;char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。</div><div>&nbsp; &nbsp; &nbsp;因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。</div><h3><span style="font-weight: bold;">3.1.3 对齐的隐患</span></h3><h4><span style="font-weight: bold;">3.1.3.1 数据类型转换</span></h4><div>&nbsp; &nbsp; &nbsp;代码中关于对齐的隐患，很多是隐式的。例如，在强制类型转换的时候：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 int main(void){</div><div>2 unsigned int i = 0x12345678;</div><div>3</div><div>4 unsigned char *p = (unsigned char *)&amp;i;</div><div>5 *p = 0x00;</div><div>6 unsigned short *p1 = (unsigned short *)(p+1);</div><div>7 *p1 = 0x0000;</div><div>8</div><div>9 return 0;</div><div>10 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐。</div><div>&nbsp; &nbsp; &nbsp;又如对于3.1.1节的结构体struct B，定义如下函数：</div><div>1 void Func(struct B *p){</div><div>2 //Code</div><div>3 }</div><div>&nbsp; &nbsp; &nbsp;在函数体内如果直接访问p-&gt;a，则很可能会异常。因为MIPS认为a是int，其地址应该是4的倍数，但p-&gt;a的地址很可能不是4的倍数。</div><div>&nbsp; &nbsp; &nbsp;如果p的地址不在对齐边界上就可能出问题，比如p来自一个跨CPU的数据包(多种数据类型的数据被按顺序放置在一个数据包中传输)，或p是经过指针移位算出来的。因此要特别注意跨CPU数据的接口函数对接口输入数据的处理，以及指针移位再强制转换为结构指针进行访问时的安全性。</div><div>&nbsp; &nbsp; &nbsp;解决方式如下：</div><div>&nbsp; &nbsp; &nbsp;1) 定义一个此结构的局部变量，用memmove方式将数据拷贝进来。</div><div>1 void Func(struct B *p){</div><div>2 struct B tData;</div><div>3 memmove(&amp;tData, p, sizeof(struct B));</div><div>4 //此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上</div><div>5 }</div><div>&nbsp; &nbsp; &nbsp;注意：如果能确定p的起始地址没问题，则不需要这么处理；如果不能确定(比如跨CPU输入数据、或指针移位运算出来的数据要特别小心)，则需要这样处理。</div><div>&nbsp; &nbsp; &nbsp;2) 用#pragma pack (1)将STRUCT_T定义为1字节对齐方式。</div><h4><span style="font-weight: bold;">3.1.3.2 处理器间数据通信</span></h4><div>&nbsp; &nbsp; &nbsp;处理器间通过消息(对于C/C++而言就是结构体)进行通信时，需要注意字节对齐以及字节序的问题。</div><div>&nbsp; &nbsp; &nbsp;大多数编译器提供内存对其的选项供用户使用。这样用户可以根据处理器的情况选择不同的字节对齐方式。例如C/C++编译器提供的#pragma pack(n) n=1，2，4等，让编译器在生成目标文件时，使内存数据按照指定的方式排布在1，2，4等字节整除的内存地址处。</div><div>&nbsp; &nbsp; &nbsp;然而在不同编译平台或处理器上，字节对齐会造成消息结构长度的变化。编译器为了使字节对齐可能会对消息结构体进行填充，不同编译平台可能填充为不同的形式，大大增加处理器间数据通信的风险。</div><div>&nbsp; &nbsp; &nbsp;下面以32位处理器为例，提出一种内存对齐方法以解决上述问题。</div><div>&nbsp; &nbsp; &nbsp;对于本地使用的数据结构，为提高内存访问效率，采用四字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少四字节对齐导致的成员之间的空隙，降低内存开销。</div><div>&nbsp; &nbsp; &nbsp;对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用一字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式自己对消息中成员进行四字节对齐。</div><div>&nbsp; &nbsp; &nbsp;数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。顺序安排原则是：四字节的放在最前面，两字节的紧接最后一个四字节成员，一字节紧接最后一个两字节成员，填充字节放在最后。</div><div>&nbsp; &nbsp; &nbsp;举例如下：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 typedef struct tag_T_MSG{</div><div>2 long ParaA;</div><div>3 long ParaB;</div><div>4 short ParaC；</div><div>5 char ParaD;</div><div>6 char Pad; //填充字节</div><div>7 }T_MSG;</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><h4><span style="font-weight: bold;">3.1.3.3 排查对齐问题</span></h4><div>&nbsp; &nbsp; &nbsp;如果出现对齐或者赋值问题可查看：</div><div>&nbsp; &nbsp; &nbsp;1) 编译器的字节序大小端设置；</div><div>&nbsp; &nbsp; &nbsp;2) 处理器架构本身是否支持非对齐访问；</div><div>&nbsp; &nbsp; &nbsp;3) 如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</div><h3><span style="font-weight: bold;">3.1.4 更改对齐方式</span></h3><div>&nbsp; &nbsp; &nbsp;主要是更改C编译器的缺省字节对齐方式。&nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp;在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</div><ul><li><div>使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；</div></li><li><div>使用伪指令#pragma pack()： 取消自定义字节对齐方式。</div></li></ul><div>&nbsp; &nbsp; &nbsp;另外，还有如下的一种方式(GCC特有语法)：</div><ul><li><div>__attribute((aligned (n)))： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。</div></li><li><div>__attribute__ ((packed))： 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</div></li></ul><div>&nbsp; &nbsp; 【注】__attribute__机制是GCC的一大特色，可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。详细介绍请参考：</div><div>&nbsp; &nbsp; &nbsp;<a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html" style="text-decoration: underline;">http://www.unixwiz.net/techtips/gnu-c-attributes.html</a></div><div>&nbsp; &nbsp; 下面具体针对MS VC/C++ 6.0编译器介绍下如何修改编译器默认对齐值。</div><div>&nbsp; &nbsp; &nbsp;1) VC/C++ IDE环境中，可在[Project]|[Settings]，C/C++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</div><div align="center"><en-media hash="8e20eee80f171b61187ea97f6215f1df" height="140" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/jpeg" width="318"/></div><div>&nbsp; &nbsp; &nbsp;VC/C++中的编译选项有/Zp[1|2|4|8|16]，/Zpn表示以n字节边界对齐。n字节边界对齐是指一个成员的地址必须安排在成员的尺寸的整数倍地址上或者是n的整数倍地址上，取它们中的最小值。亦即：min(sizeof(member), n)。</div><div>&nbsp; &nbsp; &nbsp;实际上，1字节边界对齐也就表示结构成员之间没有空洞。</div><div>&nbsp; &nbsp; &nbsp;/Zpn选项应用于整个工程，影响所有参与编译的结构体。在Struct member alignment中可选择不同的对齐值来改变编译选项。</div><div>&nbsp; &nbsp; &nbsp;2) 在编码时，可用#pragma pack动态修改对齐值。具体语法说明见附录5.3节。</div><div>&nbsp; &nbsp; &nbsp;自定义对齐值后要用#pragma pack()来还原，否则会对后面的结构造成影响。</div><div>&nbsp; &nbsp; 【例3】分析如下结构体C：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 #pragma pack(2) //指定按2字节对齐</div><div>2 struct C{</div><div>3 char b;</div><div>4 int a;</div><div>5 short c;</div><div>6 };</div><div>7 #pragma pack() //取消指定对齐，恢复缺省对齐</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;变量b自身对齐值为1，指定对齐值为2，所以有效对齐值为1，假设C从0x0000开始，则b存放在0x0000，符合0x0000%1= 0；变量a自身对齐值为4，指定对齐值为2，所以有效对齐值为2，顺序存放在0x0002~0x0005四个连续字节中，符合0x0002%2=0。变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006~0x0007中，符合 0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。C的自身对齐值为4，所以其有效对齐值为2。又8%2=0，C只占用0x0000~0x0007的八个字节。所以sizeof(struct C) = 8。</div><div>&nbsp; &nbsp; &nbsp;注意，结构体对齐到的字节数并非完全取决于当前指定的pack值，如下：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 #pragma pack(8)</div><div>2 struct D{</div><div>3 char b;</div><div>4 short a;</div><div>5 char c;</div><div>6 };</div><div>7 #pragma pack()</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;虽然#pragma pack(8)，但依然按照两字节对齐，所以sizeof(struct D)的值为6。因为：对齐到的字节数 = min｛当前指定的pack值，最大成员大小｝。</div><div>&nbsp; &nbsp; &nbsp;另外，GNU GCC编译器中按1字节对齐可写为以下形式：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 #define GNUC_PACKED __attribute__((packed))</div><div>2 struct C{</div><div>3 char b;</div><div>4 int a;</div><div>5 short c;</div><div>6 }GNUC_PACKED;</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;此时sizeof(struct C)的值为7。</div><h2><span style="font-weight: bold;">3.2 栈内存对齐</span></h2><div>&nbsp; &nbsp; &nbsp;在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。</div><div>&nbsp; &nbsp; 【例4】</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 #pragma pack(push, 1) //后面可改为1, 2, 4, 8</div><div>2 struct StrtE{</div><div>3 char m1;</div><div>4 long m2;</div><div>5 };</div><div>6 #pragma pack(pop)</div><div>7</div><div>8 int main(void){</div><div>9 char a;</div><div>10 short b;</div><div>11 int c;</div><div>12 double d[2];</div><div>13 struct StrtE s;</div><div>14</div><div>15 printf(&quot;a address: %p\n&quot;, &amp;a);</div><div>16 printf(&quot;b address: %p\n&quot;, &amp;b);</div><div>17 printf(&quot;c address: %p\n&quot;, &amp;c);</div><div>18 printf(&quot;d[0] address: %p\n&quot;, &amp;(d[0]));</div><div>19 printf(&quot;d[1] address: %p\n&quot;, &amp;(d[1]));</div><div>20 printf(&quot;s address: %p\n&quot;, &amp;s);</div><div>21 printf(&quot;s.m2 address: %p\n&quot;, &amp;(s.m2));</div><div>22 return 0;</div><div>23 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;结果如下：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 a address: 0xbfc4cfff</div><div>2 b address: 0xbfc4cffc</div><div>3 c address: 0xbfc4cff8</div><div>4 d<span style="font-weight: bold;">[</span>0<span style="font-weight: bold;">]</span> address: 0xbfc4cfe8</div><div>5 d<span style="font-weight: bold;">[</span>1<span style="font-weight: bold;">]</span> address: 0xbfc4cff0</div><div>6 s address: 0xbfc4cfe3</div><div>7 s.m2 address: 0xbfc4cfe4</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;可以看出都是对齐到4字节。并且前面的char和short并没有被凑在一起(成4字节)，这和结构体内的处理是不同的。</div><div>&nbsp; &nbsp; &nbsp;至于为什么输出的地址值是变小的，这是因为该平台下的栈是倒着“生长”的。</div><h2><span style="font-weight: bold;">3.3 位域对齐</span></h2><h3><span style="font-weight: bold;">3.3.1 位域定义</span></h3><div>&nbsp; &nbsp; &nbsp;有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。</div><div>&nbsp; &nbsp; &nbsp;位域是一种特殊的结构成员或联合成员(即只能用在结构或联合中)，用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位。这样就可用一个字节的二进制位域来表示几个不同的对象。</div><div>&nbsp; &nbsp; &nbsp;<en-media hash="8ccdfd9188efb8e3f82e78322ee2615d" type="image/png"/></div><div>&nbsp; &nbsp; &nbsp;位域在本质上就是一种结构类型，不过其成员是按二进位分配的。位域变量的说明与结构变量说明的方式相同，可先定义后说明、同时定义说明或直接说明。&nbsp; &nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp;位域的使用主要为下面两种情况：</div><div>&nbsp; &nbsp; &nbsp;1) 当机器可用内存空间较少而使用位域可大量节省内存时。如把结构作为大数组的元素时。</div><div>&nbsp; &nbsp; &nbsp;2) 当需要把一结构体或联合映射成某预定的组织结构时。如需要访问字节内的特定位时。</div><h3><span style="font-weight: bold;">3.3.2 对齐准则</span></h3><div>&nbsp; &nbsp; &nbsp;位域成员不能单独被取sizeof值。下面主要讨论含有位域的结构体的sizeof。</div><div>&nbsp; &nbsp; &nbsp;C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。</div><div>&nbsp; &nbsp; &nbsp;其对齐规则大致为：</div><div>&nbsp; &nbsp; &nbsp;1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</div><div>&nbsp; &nbsp; &nbsp;2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</div><div>&nbsp; &nbsp; &nbsp;3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</div><div>&nbsp; &nbsp; &nbsp;4) 如果位域字段之间穿插着非位域字段，则不进行压缩；</div><div>&nbsp; &nbsp; &nbsp;5) 整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</div><div>&nbsp; &nbsp; 【例5】</div><div>1 struct BitField{</div><div>2 char element1 : 1;</div><div>3 char element2 : 4;</div><div>4 char element3 : 5;</div><div>5 };</div><div>&nbsp; &nbsp; &nbsp;位域类型为char，第1个字节仅能容纳下element1和element2，所以element1和element2被压缩到第1个字节中，而element3只能从下一个字节开始。因此sizeof(BitField)的结果为2。</div><div>&nbsp; &nbsp; 【例6】</div><div>1 struct BitField1{</div><div>2 char element1 : 1;</div><div>3 short element2 : 5;</div><div>4 char element3 : 7;</div><div>5 };</div><div>&nbsp; &nbsp; &nbsp;由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。</div><div>&nbsp; &nbsp; 【例7】</div><div>1 struct BitField2{</div><div>2 char element1 : 3;</div><div>3 char element2 ;</div><div>4 char element3 : 5;</div><div>5 };</div><div>&nbsp; &nbsp; &nbsp;非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。</div><div>&nbsp; &nbsp; 【例8】</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 struct StructBitField{</div><div>2 int element1 : 1;</div><div>3 int element2 : 5;</div><div>4 int element3 : 29;</div><div>5 int element4 : 6;</div><div>6 char element5 :2;</div><div>7 char stelement; //在含位域的结构或联合中也可同时说明普通成员</div><div>8 };</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在VC6中其sizeof为16。</div><h3><span style="font-weight: bold;">3.3.3 注意事项</span></h3><div>&nbsp; &nbsp; &nbsp;关于位域操作有几点需要注意：</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>1) 位域的地址不能访问，因此不允许将&amp;运算符用于位域。不能使用指向位域的指针也不能使用位域的数组(数组是种特殊指针)。</div><div>&nbsp; &nbsp; &nbsp;例如，scanf函数无法直接向位域中存储数据：</div><div>1 int main(void){</div><div>2 struct BitField1 tBit;</div><div>3 scanf(&quot;%d&quot;, &amp;tBit.element2); //error: cannot take address of bit-field &apos;element2&apos;</div><div>4 return 0;</div><div>5 }</div><div>&nbsp; &nbsp; &nbsp;可用scanf函数将输入读入到一个普通的整型变量中，然后再赋值给tBit.element2。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>2) 位域不能作为函数返回的结果。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>3) 位域以定义的类型为单位，且位域的长度不能够超过所定义类型的长度。例如定义int a:33是不允许的。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>4) 位域可以不指定位域名，但不能访问无名的位域。</div><div>&nbsp; &nbsp; &nbsp;位域可以无位域名，只用作填充或调整位置，占位大小取决于该类型。例如，char :0表示整个位域向后推一个字节，即该无名位域后的下一个位域从下一个字节开始存放，同理short :0和int :0分别表示整个位域向后推两个和四个字节。</div><div>&nbsp; &nbsp; &nbsp;当空位域的长度为具体数值N时(如int :2)，该变量仅用来占位N位。</div><div>&nbsp; &nbsp; 【例9】</div><div>1 struct BitField3{</div><div>2 char element1 : 3;</div><div>3 char :6;</div><div>4 char element3 : 5;</div><div>5 };</div><div>&nbsp; &nbsp; &nbsp;结构体大小为3。因为element1占3位，后面要保留6位而char为8位，所以保留的6位只能放到第2个字节。同样element3只能放到第3字节。</div><div>1 struct BitField4{</div><div>2 char element1 : 3;</div><div>3 char :0;</div><div>4 char element3 : 5;</div><div>5 };</div><div>&nbsp; &nbsp; &nbsp;长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。故上面的结构体大小为2。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>5) 位域的表示范围。</div><ul><li><div>位域的赋值不能超过其可以表示的范围；</div></li><li><div>位域的类型决定该编码能表示的值的结果。</div></li></ul><div>&nbsp; &nbsp; &nbsp;对于第二点，若位域为unsigned类型，则直接转化为正数；若非unsigned类型，则先判断最高位是否为1，若为1表示补码，则对其除符号位外的所有位取反再加一得到最后的结果数据(原码)。如：</div><div>1 unsigned int p:3 = 111; //p表示7</div><div>2 int p:3 = 111; //p 表示-1，对除符号位之外的所有位取反再加一</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>6) 带位域的结构在内存中各个位域的存储方式取决于编译器，既可从左到右也可从右到左存储。</div><div>&nbsp; &nbsp; 【例10】在VC6下执行下面的代码：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>int main(void){</div><div>union{</div><div>int i;</div><div>struct{</div><div>char a : 1;</div><div>char b : 1;</div><div>char c : 2;</div><div>}bits;</div><div>}num;</div><div><br/></div><div>printf(&quot;Input an integer for i(0~15): &quot;);</div><div>scanf(&quot;%d&quot;, &amp;num.i);</div><div>printf(&quot;i = %d, cba = %d %d %d\n&quot;, num.i, num.bits.c, num.bits.b, num.bits.a);</div><div>return 0;</div><div>}</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;输入i值为11，则输出为i = 11, cba = -2 -1 -1。</div><div>&nbsp; &nbsp; &nbsp;Intel x86处理器按小字节序存储数据，所以bits中的位域在内存中放置顺序为ccba。当num.i置为11时，bits的最低有效位(即位域a)的值为1，a、b、c按低地址到高地址分别存储为10、1、1(二进制)。</div><div>&nbsp; &nbsp; &nbsp;但为什么最后的打印结果是a=-1而不是1？</div><div>&nbsp; &nbsp; &nbsp;因为位域a定义的类型signed char是有符号数，所以尽管a只有1位，仍要进行符号扩展。1做为补码存在，对应原码-1。</div><div>&nbsp; &nbsp; &nbsp;如果将a、b、c的类型定义为unsigned char，即可得到cba = 2 1 1。1011即为11的二进制数。</div><div>&nbsp; &nbsp; &nbsp;注：C语言中，不同的成员使用共同的存储区域的数据构造类型称为联合(或共用体)。联合占用空间的大小取决于类型长度最大的成员。联合在定义、说明和使用形式上与结构体相似。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>7) 位域的实现会因编译器的不同而不同，使用位域会影响程序可移植性。因此除非必要否则最好不要使用位域。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp;</span>8) 尽管使用位域可以节省内存空间，但却增加了处理时间。当访问各个位域成员时，需要把位域从它所在的字中分解出来或反过来把一值压缩存到位域所在的字位中。</div><h1><span style="font-weight: bold;">四 &nbsp;总结</span></h1><div>&nbsp; &nbsp; &nbsp;让我们回到引言部分的问题。</div><div>&nbsp; &nbsp; &nbsp;缺省情况下，C/C++编译器默认将结构、栈中的成员数据进行内存对齐。因此，引言程序输出就变成&quot;c1 -&gt; 0, s -&gt; 2, c2 -&gt; 4, i -&gt; 8&quot;。</div><div>&nbsp; &nbsp; &nbsp;编译器将未对齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致整个结构的尺寸变大。尽管会牺牲一点空间(成员之间有空洞)，但提高了性能。</div><div>&nbsp; &nbsp; &nbsp;也正是这个原因，引言例子中sizeof(T_ FOO)为12，而不是8。</div><div>&nbsp; &nbsp; &nbsp;总结说来，就是在结构体中，综合考虑变量本身和指定的对齐值；</div><div>在栈上，不考虑变量本身的大小，统一对齐到4字节。</div><h1><span style="font-weight: bold;">五 &nbsp;附录</span></h1><h2><span style="font-weight: bold;">5.1 字节序与网络序</span></h2><h3><span style="font-weight: bold;">5.1.1 字节序</span></h3><div>&nbsp; &nbsp; &nbsp;字节序，顾名思义就是字节的高低位存放顺序。</div><div>&nbsp; &nbsp; &nbsp;对于单字节，大部分处理器以相同的顺序处理比特位，因此单字节的存放和传输方式一般相同。</div><div>&nbsp; &nbsp; &nbsp;对于多字节数据，如整型(32位机中一般占4字节)，在不同的处理器的存放方式主要有两种(以内存中0x0A0B0C0D的存放方式为例)。</div><div>&nbsp; &nbsp; 1) 大字节序(Big-Endian，又称大端序或大尾序)</div><div>&nbsp; &nbsp; &nbsp;在计算机中，存储介质以下面方式存储整数0x0A0B0C0D则称为大字节序：</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/></colgroup><tbody><tr><td colspan="6" style="width: 780px; padding: 8px; border: 1px solid;"><div align="center">数据以8bit为单位</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">低地址方向</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0A</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0B</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0C</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0D</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">高地址方向</div></td></tr><tr><td colspan="6" style="width: 780px; padding: 8px; border: 1px solid;"><div align="center">数据以16bit为单位</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">低地址方向</div></td><td colspan="2" style="width: 260px; padding: 8px; border: 1px solid;"><div align="center">0x0A0B</div></td><td colspan="2" style="width: 260px; padding: 8px; border: 1px solid;"><div align="center">0x0C0D</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">高地址方向</div></td></tr></tbody></table><div>&nbsp; &nbsp; &nbsp;其中，最高有效位(MSB，Most Significant Byte)0x0A存储在最低的内存地址处。下个字节0x0B存在后面的地址处。同时，最高的16bit单元0x0A0B存储在低位。</div><div>&nbsp; &nbsp; &nbsp;简而言之，大字节序就是“<span style="font-weight: bold;">高字节存入低地址，低字节存入高地址</span>”。</div><div>&nbsp; &nbsp; &nbsp;这里讲个词源典故：“endian”一词来源于乔纳森·斯威夫特的小说《格列佛游记》。小说中，小人国为水煮蛋该从大的一端(Big-End)剥开还是小的一端(Little-End)剥开而争论，争论的双方分别被称为Big-endians和Little-endians。</div><div>&nbsp; &nbsp; &nbsp;1980年，Danny Cohen在其著名的论文&quot;<span style="font-style: italic;">On Holy Wars and a Plea for Peace</span>&quot;中为平息一场关于字节该以什么样的顺序传送的争论而引用了该词。</div><div>&nbsp; &nbsp; &nbsp;借用上面的典故，想象一下要把熟鸡蛋旋转着稳立起来，大头(高字节)肯定在下面(低地址)^_^</div><div>&nbsp; &nbsp; &nbsp;2) 小字节序(Little-Endian，又称小端序或小尾序)</div><div>&nbsp; &nbsp; &nbsp;在计算机中，存储介质以下面方式存储整数0x0A0B0C0D则称为小字节序：</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/></colgroup><tbody><tr><td colspan="6" style="width: 780px; padding: 8px; border: 1px solid;"><div align="center">数据以8bit为单位</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">高地址方向</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0A</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0B</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0C</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x0D</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">低地址方向</div></td></tr><tr><td colspan="6" style="width: 780px; padding: 8px; border: 1px solid;"><div align="center">数据以16bit为单位</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">高地址方向</div></td><td colspan="2" style="width: 260px; padding: 8px; border: 1px solid;"><div align="center">0x0A0B</div></td><td colspan="2" style="width: 260px; padding: 8px; border: 1px solid;"><div align="center">0x0C0D</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">低地址方向</div></td></tr></tbody></table><div>&nbsp; &nbsp; &nbsp;其中，最低有效位(LSB，Least Significant Byte)0x0D存储在最低的内存地址处。后面字节依次存在后面的地址处。同时，最低的16bit单元0x0A0B存储在低位。</div><div>&nbsp; &nbsp; &nbsp;可见，小字节序就是“<span style="font-weight: bold;">高字节存入高地址，低字节存入低地址</span>”。</div><div>&nbsp; &nbsp; &nbsp;C语言中的位域结构也要遵循比特序(类似字节序)。例如：</div><div>1 struct bitfield{</div><div>2 unsigned char a: 2;</div><div>3 unsigned char b: 6;</div><div>4 }</div><div>&nbsp; &nbsp; &nbsp;该位域结构占1个字节，假设赋值a = 0x01和b=0x02，则大字节机器上该字节为(01)(000010)，小字节机器上该字节为(000010)(01)。因此在编写可移植代码时，需要加条件编译。</div><div>&nbsp; &nbsp; &nbsp;注意，在包含位域的C结构中，若位域A在位域B之前定义，则位域A所占用的内存空间地址低于位域B所占用的内存空间。</div><div>&nbsp; &nbsp; &nbsp;对上述问题，详细的讲解可参考<a href="http://www.linuxjournal.com/article/6788" style="text-decoration: underline;">http://www.linuxjournal.com/article/6788</a>。</div><div>&nbsp; &nbsp; 另见以下联合体，在小字节机器上若low=0x01，high=0x02，则hex=0x21：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 int main(void){</div><div>2 union{</div><div>3 unsigned char hex;</div><div>4 struct{</div><div>5 unsigned char low : 4;</div><div>6 unsigned char high : 4;</div><div>7 };</div><div>8 }convert;</div><div>9 convert.low = 0x01;</div><div>10 convert.high = 0x02;</div><div>11 printf(&quot;hex = 0x%0x\n&quot;, convert.hex);</div><div>12 return 0;</div><div>13 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><h3><span style="font-weight: bold;">5.1.2 网络序</span></h3><div>&nbsp; &nbsp; &nbsp;网络传输一般采用大字节序，也称为网络字节序或网络序。IP协议中定义大字节序为网络字节序。</div><div>&nbsp; &nbsp; &nbsp;对于可移植的代码来说，将接收的网络数据转换成主机的字节序是必须的，一般会有成对的函数用于把网络数据转换成相应的主机字节序或反之(若主机字节序与网络字节序相同，通常将函数定义为空宏)。</div><div>&nbsp; &nbsp; &nbsp;伯克利socket API定义了一组转换函数，用于16和32位整数在网络序和主机字节序之间的转换。Htonl、htons用于主机序转换到网络序；ntohl、ntohs用于网络序转换到本机序。</div><div>&nbsp; &nbsp; &nbsp;注意：在大小字节序转换时，必须考虑待转换数据的长度(如5.1.1节的数据单元)。另外对于单字符或小于单字符的几个bit数据，是不必转换的，因为在机器存储和网络发送的一个字符内的bit位存储顺序是一致的。</div><h3><span style="font-weight: bold;">5.1.3 位序</span></h3><div>&nbsp; &nbsp; &nbsp;用于描述串行设备的传输顺序。一般硬件传输采用小字节序(先传低位)，但I2C协议采用大字节序。网络协议中只有数据链路层的底端会涉及到。</div><h3><span style="font-weight: bold;">5.1.4 处理器字节序</span></h3><div>&nbsp; &nbsp; &nbsp;不同处理器体系的字节序如下所示：</div><ul><li><div>X86、MOS Technology 6502、Z80、VAX、PDP-11等处理器为Little endian；</div></li><li><div>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC(除V9外)等处理器为Big endian；</div></li><li><div>ARM、PowerPC (除PowerPC 970外)、DEC Alpha，SPARC V9，MIPS，PA-RISC and IA64等的字节序是可配置的。</div></li></ul><h3><span style="font-weight: bold;">5.1.5 字节序编程</span></h3><div>&nbsp; &nbsp; &nbsp;请看下面的语句：</div><div>1 printf(&quot;%c\n&quot;, *((short*)&quot;AB&quot;) &gt;&gt; 8);</div><div>&nbsp; &nbsp; &nbsp;在大字节序下输出为&apos;A&apos;，小字节序下输出为&apos;B&apos;。</div><div>&nbsp; &nbsp; &nbsp;下面的代码可用来判断本地机器字节序：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 //字节序枚举类型</div><div>2 typedef enum{</div><div>3 ENDIAN_LITTLE = (INT8U)0X00,</div><div>4 ENDIAN_BIG = (INT8U)0X01</div><div>5 }E_ENDIAN_TYPE;</div><div>6</div><div>7 E_ENDIAN_TYPE GetEndianType(VOID)</div><div>8 {</div><div>9 INT32U dwData = 0x12345678;</div><div>10</div><div>11 if(0x78 == *((INT8U*)&amp;dwData))</div><div>12 return ENDIAN_LITTLE;</div><div>13 else</div><div>14 return ENDIAN_BIG;</div><div>15 }</div><div>16</div><div>17 //Start of GetEndianTypeTest//</div><div>18 #include &lt;endian.h&gt;</div><div>19 VOID GetEndianTypeTest(VOID)</div><div>20 {</div><div>21 #if _BYTE_ORDER == _LITTLE_ENDIAN</div><div>22 printf(&quot;[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n&quot;, __FUNCTION__,</div><div>23 (ENDIAN_LITTLE != GetEndianType()) ? &quot;ERROR&quot; : &quot;OK&quot;, &quot;Little&quot;);</div><div>24 #elif _BYTE_ORDER == _BIG_ENDIAN</div><div>25 printf(&quot;[%s]&lt;Test Case&gt; Result: %s, EndianType = %s!\n&quot;, __FUNCTION__,</div><div>26 (ENDIAN_BIG != GetEndianType()) ? &quot;ERROR&quot; : &quot;OK&quot;, &quot;Big&quot;);</div><div>27 #endif</div><div>28 }</div><div>29 //End of GetEndianTypeTest//</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;在字节序不同的平台间的交换数据时，必须进行转换。比如对于int类型，大字节序写入文件：</div><div>1 int i = 100;</div><div>2 write(fd, &amp;i, sizeof(int));</div><div>&nbsp; &nbsp; &nbsp;小字节序读出后：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 int i;</div><div>2 read(fd, &amp;i, sizeof(int));</div><div>3 char buf[sizeof(int)];</div><div>4 memcpy(buf, &amp;i, sizeof(int));</div><div>5 for(i = 0; i &lt; sizeof(int); i++)</div><div>6 {</div><div>7 int v = buf[sizeof(int) - i - 1];</div><div>8 buf[sizeof(int) - 1] = buf[i];</div><div>9 buf[i] = v;</div><div>10 }</div><div>11 memcpy(&amp;i, buf, sizeof(int));</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;上面仅仅是个例子。在不同平台间即使不存在字节序的问题，也尽量不要直接传递二进制数据。作为可选的方式就是使用文本来交换数据，这样至少可以避免字节序的问题。</div><div>&nbsp; &nbsp; &nbsp;很多的加密算法为了追求速度，都会采取字符串和数字之间的转换，在计算完毕后，必须注意字节序的问题，在某些实现中可以见到使用预编译的方式来完成，这样很不方便，如果使用前面的语句来判断，就可以自动适应。</div><div>&nbsp; &nbsp; &nbsp;字节序问题不仅影响异种平台间传递数据，还影响诸如读写一些特殊格式文件之类程序的可移植性。此时使用预编译的方式来完成也是一个好办法。</div><h2><span style="font-weight: bold;">5.2 对齐时的填充字节</span></h2><div>&nbsp; &nbsp; &nbsp;代码如下：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 struct A{</div><div>2 char c;</div><div>3 int i;</div><div>4 short s;</div><div>5 };</div><div>6 int main(void){</div><div>7 struct A a;</div><div>8 a.c = 1; a.i = 2; a.s = 3;</div><div>9 printf(&quot;sizeof(A)=%d\n&quot;, sizeof(struct A));</div><div>10 return 0;</div><div>11 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;执行后输出为sizeof(A)=12。</div><div>&nbsp; &nbsp; &nbsp;VC6.0环境中，在main函数打印语句前设置断点，执行到断点处时根据结构体a的地址查看变量存储如下：</div><div><en-media hash="08b45aff871f6e0d9b6af0ee44f118cd" height="65" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/jpeg" width="374"/></div><div>&nbsp; &nbsp; &nbsp;可见填充字节为0xCC，即int3中断。</div><h2><span style="font-weight: bold;">5.3 pragma pack语法说明</span></h2><div><span style="font-weight: bold;">#pragma&nbsp; pack(n)</span></div><div><span style="font-weight: bold;">#pragma pack(push, 1)</span></div><div><span style="font-weight: bold;">#pragma pack(pop)</span>&nbsp; &nbsp; &nbsp;</div><div>1) #pragma pack(n)</div><div>&nbsp; &nbsp; &nbsp;该指令指定结构和联合成员的紧凑对齐。而一个完整的转换单元的结构和联合的紧凑对齐由/ Z p选项设置。紧凑对齐用pack编译指示在数据说明层设置。该编译指示在其出现后的第一个结构或者联合说明处生效。该编译指示对定义无效。</div><div>&nbsp; &nbsp; &nbsp;当使用#pragma pack (n) 时，n 为1、2、4、8 或1 6 。第一个结构成员后的每个结构成员都被存储在更小的成员类型或n字节界限内。如果使用无参量的#pragma pack，结构成员被紧凑为以/ Z p指定的值。该缺省/ Z p紧凑值为/ Z p 8。</div><div>&nbsp; &nbsp; &nbsp;2. 编译器也支持以下增强型语法：</div><div>&nbsp; &nbsp; &nbsp;#pragma&nbsp; pack( [ [ { push | pop } , ] [identifier, ] ] [ n] )</div><div>&nbsp; &nbsp; &nbsp;若不同的组件使用pack编译指示指定不同的紧凑对齐, 这个语法允许你把程序组件组合为一个单独的转换单元。</div><div>&nbsp; &nbsp; &nbsp;带push参量的pack编译指示的每次出现将当前的紧凑对齐存储到一个内部编译器堆栈中。编译指示的参量表从左到右读取。如果使用push，则当前紧凑值被存储起来；如果给出一个n值，该值将成为新的紧凑值。若指定一个标识符，即选定一个名称，则该标识符将和这个新的的紧凑值联系起来。</div><div>&nbsp; &nbsp; &nbsp;带一个pop参量的pack编译指示的每次出现都会检索内部编译器堆栈顶的值，并使该值为新的紧凑对齐值。如果使用pop参量且内部编译器堆栈是空的,则紧凑值为命令行给定的值，并将产生一个警告信息。若使用pop且指定一个n值，该值将成为新的紧凑值。</div><div>&nbsp; &nbsp; &nbsp;若使用pop且指定一个标识符，所有存储在堆栈中的值将从栈中删除，直到找到一个匹配的标识符。这个与标识符相关的紧凑值也从栈中移出，并且这个仅在标识符入栈之前存在的紧凑值成为新的紧凑值。如果未找到匹配的标识符, 将使用命令行设置的紧凑值，并且将产生一个一级警告。缺省紧凑对齐为8。</div><div>&nbsp; &nbsp; &nbsp;pack编译指示的新的增强功能让你在编写头文件时，确保在遇到该头文件的前后的紧凑值是一样的。</div><h2><span style="font-weight: bold;">5.4 Intel关于内存对齐的说明</span></h2><div>&nbsp; &nbsp; &nbsp;以下内容节选自《Intel Architecture 32 Manual》。</div><div>&nbsp; &nbsp; &nbsp;字、双字和四字在自然边界上不需要在内存中对齐。(对于字、双字和四字来说，自然边界分别是偶数地址，可以被4整除的地址，和可以被8整除的地址。)</div><div>&nbsp; &nbsp; &nbsp;无论如何，为了提高程序的性能，数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。</div><div>&nbsp; &nbsp; &nbsp;一个字或双字操作数跨越了4字节边界，或者一个四字操作数跨越了8字节边界，被认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问。</div><div>&nbsp; &nbsp; &nbsp;某些操作双四字的指令需要内存操作数在自然边界上对齐。如果操作数没有对齐，这些指令将会产生一个通用保护异常(#GP)。双四字的自然边界是能够被16 整除的地址。其他操作双四字的指令允许未对齐的访问(不会产生通用保护异常)，然而，需要额外的内存总线周期来访问内存中未对齐的数据。</div><h2><span style="font-weight: bold;">5.5 不同架构处理器的对齐要求</span></h2><div>&nbsp; &nbsp; &nbsp;RISC指令集处理器(MIPS/ARM)：这种处理器的设计以效率为先，要求所访问的多字节数据(short/int/ long)的地址必须是为此数据大小的倍数，如short数据地址应为2的倍数，long数据地址应为4的倍数，也就是说是对齐的。</div><div>&nbsp; &nbsp; &nbsp;CISC指令集处理器(X86)：没有上述限制。</div><div><span style="font-weight: bold;">&nbsp; &nbsp; &nbsp; 对齐处理策略</span></div><div>&nbsp; &nbsp; &nbsp;访问非对齐多字节数据时(pack数据)，编译器会将指令拆成多条(因为非对齐多字节数据可能跨越地址对齐边界)，保证每条指令都从正确的起始地址上获取数据，但也因此效率比较低。</div><div>&nbsp; &nbsp; &nbsp;访问对齐数据时则只用一条指令获取数据，因此对齐数据必须确保其起始地址是在对齐边界上。如果不是在对齐的边界，对X86 CPU是安全的，但对MIPS/ARM这种RISC CPU会出现“总线访问异常”。</div><div>&nbsp; &nbsp; &nbsp;为什么X86是安全的呢？</div><div>&nbsp; &nbsp; &nbsp;X86 CPU是如何进行数据对齐的。X86&nbsp; CPU的EFLAGS寄存器中包含一个特殊的位标志，称为AC(对齐检查的英文缩写)标志。按照默认设置，当CPU首次加电时，该标志被设置为0。当该标志是0时，CPU能够自动执行它应该执行的操作，以便成功地访问未对齐的数据值。然而，如果该标志被设置为1，每当系统试图访问未对齐的数据时，CPU就会发出一个INT 17H中断。X86的Windows 2000和Windows &nbsp; 98版本从来不改变这个CPU标志位。因此，当应用程序在X86处理器上运行时，你根本看不到应用程序中出现数据未对齐的异常条件。</div><div>&nbsp; &nbsp; &nbsp;为什么MIPS/ARM不安全呢？</div><div>&nbsp; &nbsp; &nbsp;因为MIPS/ARM&nbsp; CPU不能自动处理对未对齐数据的访问。当未对齐的数据访问发生时，CPU就会将这一情况通知操作系统。这时，操作系统将会确定它是否应该引发一个数据未对齐异常条件，对vxworks是会触发这个异常的。</div><h2><span style="font-weight: bold;">5.6 ARM下的对齐处理</span></h2><div>&nbsp; &nbsp; &nbsp;有部分摘自ARM编译器文档对齐部分。&nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp;对齐的使用：</div><div>&nbsp; &nbsp; &nbsp;1) __align(num)</div><div>&nbsp; &nbsp; &nbsp;用于修改最高级别对象的字节边界。在汇编中使用LDRD或STRD时就要用到此命令__align(8)进行修饰限制。来保证数据对象是相应对齐。</div><div>&nbsp; &nbsp; &nbsp;这个修饰对象的命令最大是8个字节限制，可以让2字节的对象进行4字节对齐，但不能让4字节的对象2字节对齐。</div><div>&nbsp; &nbsp; &nbsp;__align是存储类修改，只修饰最高级类型对象，不能用于结构或者函数对象。&nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp;2) __packed</div><div>&nbsp; &nbsp; &nbsp;进行一字节对齐。需注意：</div><ul><li><div>不能对packed的对象进行对齐；</div></li><li><div>所有对象的读写访问都进行非对齐访问；</div></li><li><div>float及包含float的结构联合及未用__packed的对象将不能字节对齐；</div></li><li><div>__packed对局部整型变量无影响。</div></li><li><div>强制由unpacked对象向packed对象转化时未定义。整型指针可以合法定义为packed，如__packed int* p(__packed int 则没有意义)</div></li></ul><div>&nbsp; &nbsp; &nbsp;对齐或非对齐读写访问可能存在的问题：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 //定义如下结构，b的起始地址不对齐。在栈中访问b可能有问题，因为栈上数据对齐访问</div><div>2 __packed struct STRUCT_TEST{</div><div>3 char a;</div><div>4 int b;</div><div>5 char c;</div><div>6 };</div><div>7 //将下面的变量定义成全局静态(不在栈上)</div><div>8 static char *p;</div><div>9 static struct STRUCT_TEST a;</div><div>10 void Main(){</div><div>11 __packed int *q; //定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</div><div>12</div><div>13 p = (char*)&amp;a;</div><div>14 q = (int*)(p + 1);</div><div>15 *q = 0x87654321;</div><div>16 /* 得到赋值的汇编指令很清楚</div><div>17 ldr r5,0x20001590 ; = #0x12345678</div><div>18 [0xe1a00005] mov r0,r5</div><div>19 [0xeb0000b0] bl __rt_uwrite4 //在此处调用一个写4字节的操作函数</div><div>20</div><div>21 [0xe5c10000] strb r0,[r1,#0] //函数进行4次strb操作然后返回，正确访问数据</div><div>22 [0xe1a02420] mov r2,r0,lsr #8</div><div>23 [0xe5c12001] strb r2,[r1,#1]</div><div>24 [0xe1a02820] mov r2,r0,lsr #16</div><div>25 [0xe5c12002] strb r2,[r1,#2]</div><div>26 [0xe1a02c20] mov r2,r0,lsr #24</div><div>27 [0xe5c12003] strb r2,[r1,#3]</div><div>28 [0xe1a0f00e] mov pc,r14</div><div>29</div><div>30 若q未加__packed修饰则汇编出来指令如下(会导致奇地址处访问失败)：</div><div>31 [0xe59f2018] ldr r2,0x20001594 ; = #0x87654321</div><div>32 [0xe5812000] str r2,[r1,#0]</div><div>33 */</div><div>34 //这样很清楚地看到非对齐访问如何产生错误，以及如何消除非对齐访问带来的问题</div><div>35 //也可看到非对齐访问和对齐访问的指令差异会导致效率问题</div><div>36 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><h2><span style="font-weight: bold;">5.7 《The C Book》之位域篇</span></h2><div>&nbsp; &nbsp; &nbsp;While we&apos;re on the subject of structures, we might as well look at bitfields. They can only be declared inside a structure or a union, and allow you to specify some very small objects of a given number of bits in length. Their usefulness is limited and they aren&apos;t seen in many programs, but we&apos;ll deal with them anyway. This example should help to make things clear:</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 struct{</div><div>2 unsigned field1 :4; //field 4 bits wide</div><div>3 unsigned :3; //unnamed 3 bit field(allow for padding)</div><div>4 signed field2 :1; //one-bit field(can only be 0 or -1 in two&apos;s complement)</div><div>5 unsigned :0; //align next field on a storage unit</div><div>6 unsigned field3 :6;</div><div>7 }full_of_fields;</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;Each field is accessed and manipulated as if it were an ordinary member of a structure. The keywords signed and unsigned mean what you would expect, except that it is interesting to note that a 1-bit signed field on a two&apos;s complement machine can only take the values 0 or -1. The declarations are permitted to include the const and volatile qualifiers.</div><div>&nbsp; &nbsp; &nbsp;The main use of bitfields is either to allow tight packing of data or to be able to specify the fields within some externally produced data files. C gives no guarantee of the ordering of fields within machine words, so if you do use them for the latter reason, you program will not only be non-portable, it will be compiler-dependent too. The Standard says that fields are packed into ‘storage units’, which are typically machine words. The packing order, and whether or not a bitfield may cross a storage unit boundary, are implementation defined. To force alignment to a storage unit boundary, a zero width field is used before the one that you want to have aligned.</div><div>&nbsp; &nbsp; &nbsp;Be careful using them. It can require a surprising amount of run-time code to manipulate these things and you can end up using more space than they save.</div><div>&nbsp; &nbsp; &nbsp;Bit fields do not have addresses—you can&apos;t have pointers to them or arrays of them.</div><h2><span style="font-weight: bold;">5.8 C语言字节相关面试题</span></h2><h3><span style="font-weight: bold;">5.8.1 Intel/微软C语言面试题</span></h3><div>&nbsp; &nbsp; &nbsp;请看下面的问题：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 #pragma pack(8)</div><div>2 struct s1{</div><div>3 short a;</div><div>4 long b;</div><div>5 };</div><div>6 struct s2{</div><div>7 char c;</div><div>8 s1 d;</div><div>9 long long e; //VC6.0下可能要用__int64代替双long</div><div>10 };</div><div>11 #pragma pack()</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;问：1. sizeof(s2) = ？ 2. s2的s1中的a后面空了几个字节接着是b？</div><div>&nbsp; &nbsp; 【分析】</div><div>&nbsp; &nbsp; &nbsp;成员对齐有一个重要的条件，即每个成员分别按自己的方式对齐。</div><div>&nbsp; &nbsp; &nbsp;也就是说上面虽然指定了按8字节对齐，但并不是所有的成员都是以8字节对齐。其对齐的规则是：每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是8字节)中较小的一个对齐，并且结构的长度必须为所用过的所有对齐参数的整数倍，不够就补空字节。</div><div>&nbsp; &nbsp; &nbsp;s1中成员a是1字节，默认按1字节对齐，而指定对齐参数为8，两值中取1，即a按1字节对齐；成员b是4个字节，默认按4字节对齐，这时就按4字节对齐，所以sizeof(s1)应该为8；</div><div>&nbsp; &nbsp; &nbsp;s2中c和s1中a一样，按1字节对齐。而d 是个8字节结构体，其默认对齐方式就是所有成员使用的对齐参数中最大的一个，s1的就是4。所以，成员d按4字节对齐。成员e是8个字节，默认按8字节对齐，和指定的一样，所以它对到8字节的边界上。这时，已经使用了12个字节，所以又添加4个字节的空，从第16个字节开始放置成员e。此时长度为24，并可被8(成员e按8字节对齐)整除。这样，一共使用了24个字节。</div><div>&nbsp; &nbsp; &nbsp;各个变量在内存中的布局为：</div><div>&nbsp; &nbsp; &nbsp;c***aa**</div><div>&nbsp; &nbsp; &nbsp;bbbb****</div><div>&nbsp; &nbsp; &nbsp;dddddddd &nbsp;&nbsp; &nbsp;——这种“矩阵写法”很方便看出结构体实际大小！</div><div>&nbsp; &nbsp; &nbsp;因此，sizeof(S2)结果为24，a后面空了2个字节接着是b。&nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp;这里有三点很重要：</div><div>&nbsp; &nbsp; &nbsp;1) 每个成员分别按自己的方式对齐，并能最小化长度；</div><div>&nbsp; &nbsp; &nbsp;2) 复杂类型(如结构)的默认对齐方式是其最长的成员的对齐方式，这样在成员是复杂类型时可以最小化长度；</div><div>&nbsp; &nbsp; &nbsp;3) 对齐后的长度必须是成员中最大对齐参数的整数倍，这样在处理数组时可保证每一项都边界对齐。</div><div>&nbsp; &nbsp; &nbsp;还要注意，“空结构体”(不含数据成员)的大小为1，而不是0。试想如果不占空间的话，一个空结构体变量如何取地址、两个不同的空结构体变量又如何得以区分呢？</div><h3><span style="font-weight: bold;">5.8.2 上海网宿科技面试题</span></h3><div>&nbsp; &nbsp; &nbsp;假设硬件平台是intel x86(little endian)，以下程序输出什么：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 //假设硬件平台是intel x86(little endian)</div><div>2 typedef unsigned int uint32_t;</div><div>3 void inet_ntoa(uint32_t in){</div><div>4 char b[18];</div><div>5 register char *p;</div><div>6 p = (char *)&amp;in;</div><div>7 #define UC(b) (((int)b)&amp;0xff) //byte转换为无符号int型</div><div>8 sprintf(b, &quot;%d.%d.%d.%d\n&quot;, UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));</div><div>9 printf(b);</div><div>10 }</div><div>11 int main(void){</div><div>12 inet_ntoa(0x12345678);</div><div>13 inet_ntoa(0x87654321);</div><div>14 return 0;</div><div>15 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;先看如下程序：</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>1 int main(void){</div><div>2 int a = 0x12345678;</div><div>3 char *p = (char *)&amp;a;</div><div>4 char str[20];</div><div>5 sprintf(str,&quot;%d.%d.%d.%d\n&quot;, p[0], p[1], p[2], p[3]);</div><div>6 printf(str);</div><div>7 return 0;</div><div>8 }</div><div><a href="http://loadhtml/#" style="text-decoration: underline;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>&nbsp; &nbsp; &nbsp;按照小字节序的规则，变量a在计算机中存储方式为：</div><div align="center"><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/></colgroup><tbody><tr><td rowspan="2" style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">高地址方向</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x12</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x34</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x56</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">0x78</div></td><td rowspan="2" style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">低地址方向</div></td></tr><tr><td style="border: 1px solid; width: 130px; padding: 8px;"><div align="center">p[3]</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">p[2]</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">p[1]</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div align="center">p[0]</div></td></tr></tbody></table><div><br/></div></div><div>&nbsp; &nbsp; &nbsp;注意，p并不是指向0x12345678的开头0x12，而是指向0x78。p[0]到p[1]的操作是&amp;p[0]+1，因此p[1]地址比p[0]地址大。输出结果为120.86.52.18。</div><div>&nbsp; &nbsp; &nbsp;反过来的话，令int a = 0x87654321，则输出结果为33.67.101.-121。</div><div>&nbsp; &nbsp; &nbsp;为什么有负值呢？因为系统默认的char是有符号的，本来是0x87也就是135，大于127因此就减去256得到-121。</div><div>&nbsp; &nbsp; &nbsp;想要得到正值的话只需将char *p = (char *)&amp;a改为unsigned char *p =&nbsp;(unsigned char *)&amp;a即可。</div><div>&nbsp; &nbsp; &nbsp;综上不难得出，网宿面试题的答案为120.86.52.18和33.67.101.135。</div><div><br/></div></div><div><a href="http://www.cnblogs.com/-zhangnian/p/6422559.html" style="font-weight: bold; text-decoration: none;">C++ 类和结构体所占内存大小</a></div><div>类所占内存：</div><div>类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。</div><div>摘抄部分：</div><div>成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。</div><div>(一)</div><div>class CBase</div><div>{</div><div>};</div><div>sizeof(CBase)=1；</div><div>为什么空的什么都没有是1呢？</div><div>c++要求每个实例在内存中都有独一无二的地址。//注意这句话！！！！！！！！！！</div><div>空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。</div><div>(二)</div><div>class CBase</div><div>{</div><div>int a;</div><div>char p;</div><div>};</div><div>sizeof(CBase)=8;</div><div>记得对齐的问题。int 占4字节//注意这点和struct的对齐原则很像！！！！！</div><div>char占一字节，补齐3字节</div><div>(三)</div><div>class CBase</div><div>{</div><div>public:</div><div>CBase(void);</div><div>virtual ~CBase(void);</div><div>private:</div><div>int&nbsp; a;</div><div>char *p;</div><div>};</div><div>再运行：sizeof(CBase)=12</div><div>C++ 类中有虚函数的时候有一个指向虚函数的指针（vptr），在32位系统分配指针大小为4字节。无论多少个虚函数，只有这一个指针，4字节。//注意一般的函数是没有这个指针的，而且也不占类的内存。</div><div>(四)</div><div>class CChild : public CBase</div><div>{</div><div>public:</div><div>CChild(void);</div><div>~CChild(void);</div><div>virtual void test();</div><div>private:</div><div>int b;</div><div>};</div><div>输出：sizeof(CChild)=16；</div><div>可见子类的大小是本身成员变量的大小加上父类的大小。//其中有一部分是虚拟函数表的原因，一定要知道</div><div>父类子类共享一个虚函数指针</div><div>(五)</div><div>#include&lt;iostream.h&gt;</div><div>class a {};</div><div>class b{};</div><div>class c:public a{</div><div>virtual void fun()=0;</div><div>};</div><div>class d:public b,public c{};</div><div>int main()</div><div>{</div><div>cout&lt;&lt;&quot;sizeof(a)&quot;&lt;&lt;sizeof(a)&lt;&lt;endl;</div><div>cout&lt;&lt;&quot;sizeof(b)&quot;&lt;&lt;sizeof(b)&lt;&lt;endl;</div><div>cout&lt;&lt;&quot;sizeof(c)&quot;&lt;&lt;sizeof(c)&lt;&lt;endl;</div><div>cout&lt;&lt;&quot;sizeof(d)&quot;&lt;&lt;sizeof(d)&lt;&lt;endl;</div><div>return 0;}</div><div>程序执行的输出结果为：</div><div>sizeof(a) =1</div><div>sizeof(b)=1</div><div>sizeof(c)=4</div><div>sizeof(d)=8</div><div>前三种情况比较常见，注意第四种情况。类d的大小更让初学者疑惑吧，类d是由类b，c派生迩来的，它的大小应该为二者之和5，为什么却是8 呢？这是因为为了提高实例在内存中的存取效率．类的大小往往被调整到系统的整数倍．并采取就近的法则，里哪个最近的倍数，就是该类的大小，所以类d的大小为8个字节．</div><div>总结：</div><div>空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。</div><div>（一）类内部的成员变量：</div><div>普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。</div><div>static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。</div><div>（二）类内部的成员函数：</div><div>普通函数：不占用内存。</div><div>虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的</div><div>结构体所占内存：</div><div><div>结构体存在内存对齐，类(对象)也如此，甚至于所有变量在内存中的存储也有对齐一说(只是这些对程序员是透明的，不需要关心)。实际上，这种对齐是为了在空间与复杂度上达到平衡的一种技术手段，简单的讲，是为了在可接受的空间浪费的前提下，尽可能的提高对相同运算过程的最少(快)处理。先举个例子：</div><div>&nbsp; &nbsp; 假设机器字长是32位的(即4字节，下面示例均按此字长)，也就是说处理任何内存中的数据，其实都是按32位的单位进行的。现在有2个变量：&nbsp; &nbsp;</div><ol><li><div>char A;</div></li><li><div>int B;</div></li></ol><div>&nbsp; &nbsp; &nbsp;假设这2个变量是从内存地址0开始分配的，如果不考虑对齐，应该是这样存储的(见下图,以intel上的little endian为例，为了形象，每16个字节分做一行，后同)：</div><div><en-media hash="bfb836eeb432ad60ad65a2d30472ece5" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>&nbsp; &nbsp; 因为计算机的字长是4字节的，所以在处理变量A与B时的过程可能大致为：</div><div>&nbsp; &nbsp; A:将0x00-0x03共32位读入寄存器，再通过左移24位再右移24位运算得到a的值(或与0x000000FF做与运算)</div><div>&nbsp; &nbsp; B:将0x00-0x03这32位读入寄存器，通过位运算得到低24位的值；再将0x04-0x07这32位读入寄存器，通过位运算得到高8位的值；再与最先得到的24位做位运算，才可得到整个32位的值。</div><div>&nbsp; &nbsp; 上面叙述可知，对a的处理是最简处理，可对b的处理，本身是个32位数，处理的时候却得折成2部分，之后再合并，效率上就有些低了。</div><div>&nbsp; &nbsp; 想解决这个问题，就需要付出几个字节浪费的代价，改为下图的分配方式：</div><div><en-media hash="e626a10022aab7c33099aa79aa94e44e" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>&nbsp; &nbsp; 按上面的分配方式，A的处理过程不变；B却简单得多了：只需将0x04-0x07这32位读入寄存器就OK了。</div><div>&nbsp; &nbsp; 我们可以具体谈结构体或类成员的对齐了：</div><div>&nbsp; &nbsp; 结构体在编译成机器代码后，其实就没有本身的集合概念了，而类，实际上是个加强版的结构体，类的对象在实例化时，内存中申请的就是一些变量的空间集合(类似于结构体，同时也不包含函数指针)。这些集合中的每个变量，在使用中，都需要涉及上述的加工原则，自然也就需要在效率与空间之间做出权衡。</div><div>&nbsp; &nbsp; 为了便捷加工连续多个相同类型原始变量，同时简化原始变量寻址，再汇总上述最少处理原则，通常可以将原始变量的长度做为针对此变量的分配单位，比如内存可用64个单元，如果某原始变量长度为8字节，即使机器字长为4字节，分配的时候也以8字节对齐(看似IO次数是相同的)，这样，寻址、分配时，均可以按每8字节为单位进行，简化了操作，也可以更高效。</div><div>&nbsp; &nbsp; 系统默认的对齐规则，追求的至少两点：1、变量的最高效加工 2、达到目的1的最少空间</div><div>&nbsp; &nbsp; 举个例子，一个结构体如下： &nbsp;</div><ol><li><div>//by www.datahf.net zhangyu</div></li><li><div>typedef struct T</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char c; //本身长度1字节</div></li><li><div>&nbsp; &nbsp;__int64 d;&nbsp; //本身长度8字节</div></li><li><div>&nbsp; &nbsp;int e;&nbsp; //本身长度4字节</div></li><li><div>&nbsp; &nbsp;short f;&nbsp; //本身长度2字节</div></li><li><div>&nbsp; &nbsp;char g;&nbsp; //本身长度1字节</div></li><li><div>&nbsp; &nbsp;<span style="font-weight: bold;">short</span> h;&nbsp; //本身长度2字节</div></li><li><div>};</div></li></ol><div>&nbsp; &nbsp; 假设定义了一个结构体变量C，在内存中分配到了0x00的位置，显然：</div><div>&nbsp; &nbsp; 对于成员C.c &nbsp;无论如何，也是一次寄存器读入，所以先占一个字节。</div><div>&nbsp; &nbsp; 对于成员C.d &nbsp;是个64位的变量，如果紧跟着C.c存储，则读入寄存器至少需要3次，为了实现最少的2次读入，至少需要以4字节对齐；同时对于8字节的原始变量，为了在寻址单位上统一，则需要按8字节对齐，所以，应该分配到0x08-0xF的位置。</div><div>&nbsp; &nbsp; 对于成员C.e &nbsp;是个32位的变量，自然只需满足分配起始为整数个32位即可，所以分配至0x10-0x13。</div><div>&nbsp; &nbsp; 对于成员C.f &nbsp;是个16位的变量，直接分配在0x14-0x16上，这样，反正只需一次读入寄存器后加工，边界也与16位对齐。</div><div>&nbsp; &nbsp; 对于成员C.g &nbsp;是个8位的变量，本身也得一次读入寄存器后加工，同时对于1个字节的变量，存储在任何字节开始都是对齐，所以，分配到0x17的位置。</div><div>&nbsp; &nbsp; 对于成员C.h &nbsp;是个16位的变量，为了保证与16位边界对齐，所以，分配到0x18-0x1A的位置。</div><div>&nbsp; &nbsp; 分配图如下(还不正确，耐心读下去)：</div><div><en-media hash="a6d1fe2daeb44ef2b083d1f15b4310a5" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>&nbsp; &nbsp; 结构体C的占用空间到h结束就可以了吗?我们找个示例：如果定义一个结构体数组 CA[2]，按变量分配的原则，这2个结构体应该是在内存中连续存储的，分配应该如下图： &nbsp;</div><div><en-media hash="6f81372369d8ad5ee22c213f4ca81ed1" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>&nbsp; &nbsp; 分析一下上图，明显可知，CA[1]的很多成员都不再对齐了，究其原因，是结构体的开始边界不对齐。</div><div>&nbsp; &nbsp; 那结构体的开始偏移满足什么条件才可以使其成员全部对齐呢。想一想就明白了：很简单，保证结构体长度是原始成员最长分配的整数倍即可。 &nbsp; &nbsp; 上述结构体应该按最长的.d成员对齐，即与8字节对齐，这样正确的分配图如下：</div><div><en-media hash="927618a95c863b0c38219ebcbf42286c" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>&nbsp; &nbsp; 当然结构体T的长度:sizeof(T)==0x20;</div><div>&nbsp; &nbsp; &nbsp;再举个例子，看看在默认对齐规则下，各结构体成员的对齐规则： &nbsp;</div><ol><li><div>//by www.datahf.net zhangyu</div></li><li><div>typedef struct A&nbsp;</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char c;&nbsp; //1个字节</div></li><li><div>&nbsp; &nbsp;int d;&nbsp; //4个字节，要与4字节对齐，所以分配至第4个字节处</div></li><li><div>&nbsp; &nbsp;short e;&nbsp; //2个字节， 上述两个成员过后，本身就是与2对齐的，所以之前无填充</div></li><li><div>}; //整个结构体，最长的成员为4个字节，需要总长度与4字节对齐，所以， sizeof(A)==12</div></li><li><div>typedef struct B&nbsp;</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char c;&nbsp; //1个字节</div></li><li><div>&nbsp; &nbsp;__int64 d;&nbsp; //8个字节，位置要与8字节对齐，所以分配到第8个字节处</div></li><li><div>&nbsp; &nbsp;int e;&nbsp; //4个字节，成员d结束于15字节，紧跟的16字节对齐于4字节，所以分配到16-19</div></li><li><div>&nbsp; &nbsp;short f;&nbsp; //2个字节，成员e结束于19字节，紧跟的20字节对齐于2字节，所以分配到20-21</div></li><li><div>&nbsp; &nbsp;A g;&nbsp; //结构体长为12字节，最长成员为4字节，需按4字节对齐，所以前面跳过2个字节,</div></li><li><div>//到24-35字节处</div></li><li><div>&nbsp; &nbsp;char h;&nbsp; //1个字节，分配到36字节处</div></li><li><div>&nbsp; &nbsp;int i;&nbsp; //4个字节，要对齐4字节，跳过3字节，分配到40-43 字节</div></li><li><div>}; //整个结构体的最大分配成员为8字节，所以结构体后面加5字节填充，被到48字节。故：</div></li><li><div>//sizeof(B)==48;</div></li></ol><div>&nbsp; &nbsp; 具体的分配图如下：</div><div><en-media hash="959d724bcf22aa17beb814b11e2d0c18" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>上述全部<a href="http://lib.csdn.net/base/softwaretest" target="_blank" title="软件测试知识库">测试</a>代码如下：</div><ol><li><div>//by www.datahf.net zhangyu</div></li><li><div>#include &quot;stdio.h&quot;</div></li><li><div>typedef struct A&nbsp;</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char c;</div></li><li><div>&nbsp; &nbsp;int d;</div></li><li><div>&nbsp; &nbsp;short e;</div></li><li><div>};</div></li><li><div>typedef struct B&nbsp;</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char c;</div></li><li><div>&nbsp; &nbsp;__int64 d;</div></li><li><div>&nbsp; &nbsp;int e;</div></li><li><div>&nbsp; &nbsp;short f;</div></li><li><div>&nbsp; &nbsp;A g;</div></li><li><div>&nbsp; &nbsp;char h;</div></li><li><div>&nbsp; &nbsp;int i;</div></li><li><div>};</div></li><li><div>typedef struct C&nbsp;</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char c;</div></li><li><div>&nbsp; &nbsp;__int64 d;</div></li><li><div>&nbsp; &nbsp;int e;</div></li><li><div>&nbsp; &nbsp;short f;</div></li><li><div>&nbsp; &nbsp;char g;</div></li><li><div>&nbsp; &nbsp;short h;</div></li><li><div>};</div></li><li><div>typedef struct D&nbsp;</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;char a;</div></li><li><div>&nbsp; &nbsp;short b;</div></li><li><div>&nbsp; &nbsp;char c;</div></li><li><div>};</div></li><li><div>int main()</div></li><li><div>{</div></li><li><div>&nbsp; &nbsp;B *b=new B;</div></li><li><div>&nbsp; &nbsp;void *s[32];</div></li><li><div>&nbsp; &nbsp;s[0]=b;</div></li><li><div>&nbsp; &nbsp;s[1]=&amp;b-&gt;c;</div></li><li><div>&nbsp; &nbsp;s[2]=&amp;b-&gt;d;</div></li><li><div>&nbsp; &nbsp;s[3]=&amp;b-&gt;e;</div></li><li><div>&nbsp; &nbsp;s[4]=&amp;b-&gt;f;</div></li><li><div>&nbsp; &nbsp;s[5]=&amp;b-&gt;g;</div></li><li><div>&nbsp; &nbsp;s[6]=&amp;b-&gt;h;</div></li><li><div>&nbsp; &nbsp;s[7]=&amp;b-&gt;g.c;</div></li><li><div>&nbsp; &nbsp;s[8]=&amp;b-&gt;g.d;</div></li><li><div>&nbsp; &nbsp;s[9]=&amp;b-&gt;g.e;</div></li><li><div>&nbsp; &nbsp;s[10]=&amp;b-&gt;i;</div></li><li><div>&nbsp; &nbsp;b-&gt;c= 0x11;</div></li><li><div>&nbsp; &nbsp;b-&gt;d= 0x2222222222222222;</div></li><li><div>&nbsp; &nbsp;b-&gt;e= 0x33333333;</div></li><li><div>&nbsp; &nbsp;b-&gt;f=0x4444;</div></li><li><div>&nbsp; &nbsp;b-&gt;g.c=0x50;</div></li><li><div>&nbsp; &nbsp;b-&gt;g.d=0x51515151;</div></li><li><div>&nbsp; &nbsp;b-&gt;g.e=0x5252;</div></li><li><div>&nbsp; &nbsp;b-&gt;h=0x66;</div></li><li><div>&nbsp; &nbsp;int i1=sizeof(A);</div></li><li><div>&nbsp; &nbsp;int i2=sizeof(B);</div></li><li><div>&nbsp; &nbsp;int i3=sizeof(C);</div></li><li><div>&nbsp; &nbsp;int i4=sizeof(D);</div></li><li><div>&nbsp; &nbsp;printf(&quot;i1:%d\ni2:%d\ni3:%d\ni4:%d\n&quot;,i1,i2,i3,i4);//12 48 32 6&nbsp;</div></li><li><div>}</div></li></ol><div>运行时的内存情况如下图：</div><div><en-media hash="f0da36069aa3feeb45c931a145052ef5" style="border: 0px; border: 0px; height: auto; max-width: 300px !important; max-width: 900px;" type="image/png"/></div><div>最后，简单加工一下转载过来的内存对齐正式原则：</div><div>&nbsp; 先介绍四个概念：</div><div>1)数据类型自身的对齐值：基本数据类型的自身对齐值，等于sizeof(基本数据类型)。</div><div>2)指定对齐值：#pragma pack (value)时的指定对齐值value。</div><div>3)结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</div><div>4)数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小的那个值。</div><div>&nbsp; 有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的&quot;存放起始地址%N=0&quot;.而<a href="http://lib.csdn.net/base/datastructure" target="_blank" title="算法与数据结构知识库">数据结构</a>中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是 数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整 数倍)</div><div>#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。</div><div>如#pragma pack (1) &nbsp;/*指定按2字节对齐*/</div><div>#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div></div><div><br/></div><div style="clear: both;"/><div><br/></div><div><div>原</div><h1>【C++ Primer】 神秘的 sizeof(union) 、sizeof(struct) 和内存对齐技术</h1></div><div>2012年05月17日 15:30:10</div><div>阅读数：8355</div><div><span style="font-weight: 400;">一，union：C/C++关键字&nbsp; 共用体（联合）</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 共用体的声明和共用体变量定义与结构十分相似。形式为：</span></div><div>1</div><div>union 共用体名</div><div>2</div><div>{ 　　</div><div>3</div><div>数据类型 成员名; 　　</div><div>4</div><div>数据类型 成员名; 　　</div><div>5</div><div>... 　　</div><div>6</div><div>} 变量名;</div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型和不同长度的变量.在union中，所有的共用体成员共用一个空间，并且同一时间只能储存其中一个成员变量的值。当一个共用体被声明时, 编译程序自动地产生一个变量, 其长度为联合中<span style="font-weight: 400;">最大的变量长度的整数倍（特别注意数组）</span></span></div><div><span style="font-weight: 400;">例子一：</span></div><div><span style="font-weight: 400;">union foo{</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　int i;</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　char c;</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　double k;</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　};</span></div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">sizeof(foo); &nbsp; //double最长占用8字节，所以union foo大小为8字节</span></div><div><span style="font-weight: 400;">例子二：　</span></div><div>1</div><div>union A</div><div>2</div><div>{</div><div>3</div><div>int a[5]; //20</div><div>4</div><div>short b; //2</div><div>5</div><div>double c; //8</div><div>6</div><div>char p2; //1</div><div>7</div><div>};</div><div>8</div><div><br clear="none"/></div><div>9</div><div>struct B {</div><div>10</div><div>int n; // 4字节</div><div>11</div><div>A a; // 24字节</div><div>12</div><div>char c[10]; // 10字节</div><div>13</div><div>};</div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">&nbsp; &nbsp;&nbsp; sizeof(A) ;&nbsp; //24 &nbsp; &nbsp; 而不是20 &nbsp; &nbsp; ???</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp;&nbsp; sizeof(B) ;&nbsp; //48 &nbsp; &nbsp; 而不是？？？</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp;对齐： 分配内存时，每个成员放在长度倍数位置，如果不够，补位对齐</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp;补齐： 对整个结构变量的空间要求总长度一定是最长的成员的倍数，<span style="font-weight: 400;">不够补齐不管是对齐还是补齐，最长的成员长度超过4时，以4计。这个表述不严谨。该位数还和机器位数还有关系，在32系统中才是为4，这是因为</span></span><span style="font-weight: 400;">pragma pack(n)中n取值为4,；在64中则为8.</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp;&nbsp; A实际占用内存大小为 20字节，但是要跟 8个字节的变量double的整数倍，对齐所以为 24；</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp;&nbsp; 由于A实际占用24字节，则可以想象B<span style="font-weight: 400;">实际占用38字节，但</span><span style="font-weight: 400;">A是8字节对齐</span><span style="font-weight: 400;">的，所以int &nbsp; n和char&nbsp; &nbsp;c[10]也需要8字节对齐，总共8+24+16=48 字节。</span></span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp;</span></div><div><span style="font-weight: 400;">例子三：</span></div><div>1</div><div>union f 　　</div><div>2</div><div>{ 　　</div><div>3</div><div>char s[10]; 　　</div><div>4</div><div>int i; 　　</div><div>5</div><div>};</div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">&nbsp; &nbsp;&nbsp; sizeof(f);&nbsp; //&nbsp; 12</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 解释：在这个union中，foo的内存空间的长度为12，是int型的3倍，而并不是数组的长度10。</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;若把int改为double，则foo的内存空间为16，是double型的两倍。</span></div><div><span style="font-weight: 400;">二，struct</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp;&nbsp; 具体说明见内存对齐例子</span></div><div><span style="font-weight: 400;">三，<span style="font-weight: 400;">内存对齐</span></span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 1）概念：“内存对齐”应该是编译器的“管辖范围”。编译器为程序中的每个“数据单元”安排在适当的位置上。</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 2）原因：</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 　　</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2、性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因是：<span style="font-weight: 400;">为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</span></span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 3）对齐规则</span></div><div><span style="font-weight: 400;">&nbsp;&nbsp; 　　每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。 　　</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 规则： 　　</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 　　</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 　　</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp; 3、结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。</span></div><div><span style="font-weight: 400;">pragma&nbsp; pack(1) 时候</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp;&nbsp; 1&gt;数据成员对齐：</span></div><div>1</div><div>#pragma pack(1)</div><div>2</div><div>struct test_t</div><div>3</div><div>{</div><div>4</div><div>int a; /* int型， 长度4 &gt; 1 按1对齐；起始offset=0 0%1=0；存放位置区间[0,3] */</div><div>5</div><div>char b; /* char型， 长度1 = 1 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */</div><div>6</div><div>short c; /* short型，长度2 &gt; 1 按1对齐；起始offset=5 5%1=0；存放位置区间[5,6] */</div><div>7</div><div>char d[6]; /* char型， 长度1 = 1 按1对齐；起始offset=7 7%1=0；存放位置区间[7,C] */</div><div>8</div><div>};/*char d[6]要看成6个char型变量*/</div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; &nbsp; sizeof(test_t) ; &nbsp; &nbsp; //输出为13</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp;&nbsp; 2&gt;整体对齐</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　 &nbsp; &nbsp; 整体对齐系数 = min((max(int,short,char), 1) = 1</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　 &nbsp; &nbsp; 整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 13 &nbsp; /*13%1=0*/</span></div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">pragma pack(2) 时候</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; 1&gt;成员数据对齐</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　</span></div><div>1</div><div>#pragma pack(2)</div><div>2</div><div><br clear="none"/></div><div>3</div><div>　　struct test_t {</div><div>4</div><div><br clear="none"/></div><div>5</div><div>　　 int a; /* int型，长度4 &gt; 2 按2对齐；起始offset=0 0%2=0；存放位置区间[0,3] */</div><div>6</div><div><br clear="none"/></div><div>7</div><div>　　 char b; /* char型，长度1 &lt; 2 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */</div><div>8</div><div><br clear="none"/></div><div>9</div><div>　　short c; /* short型，长度2 = 2 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */</div><div>10</div><div><br clear="none"/></div><div>11</div><div>　　 char d[6]; /* char型，长度1 &lt; 2 按1对齐；起始offset=8 8%1=0；存放位置区间[8,D] */</div><div>12</div><div><br clear="none"/></div><div>13</div><div>　　};</div><div>14</div><div>　</div><div><br clear="none"/></div><div><br clear="none"/></div><div>　　成员总大小=14</div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　2&gt; 整体对齐</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　整体对齐系数 = min((max(int,short,char), 2) = 2</span></div><div><br clear="none"/></div><div><span style="font-weight: 400;">　　整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 14 /* 14%2=0 */</span></div><div><span style="font-weight: 400;">四，终极例子</span></div><div><span style="font-weight: 400;">入门例子一：</span></div><div>1</div><div>union A</div><div>2</div><div>{</div><div>3</div><div>int t; //4</div><div>4</div><div>short m; //2</div><div>5</div><div>char p; //1</div><div>6</div><div>};</div><div>7</div><div><br clear="none"/></div><div>8</div><div>struct B</div><div>9</div><div>{</div><div>10</div><div>A a; //4</div><div>11</div><div>double c; //8</div><div>12</div><div>char p2; //1</div><div>13</div><div>};</div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; sizeof(B);&nbsp; // 24</span></div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; B中采用double长度&nbsp; 8字节对齐方式，所以A在结构体B内 变成8字节。实际B占用 8+8+1=17。再填充成8的整数倍后位 24字节</span></div><div><span style="font-weight: 400;">变态例子二：</span></div><div>1</div><div>struct B</div><div>2</div><div>{</div><div>3</div><div>union A</div><div>4</div><div>{</div><div>5</div><div>int t; //4</div><div>6</div><div>short m; //2</div><div>7</div><div>char p; //1</div><div>8</div><div>} ;</div><div>9</div><div>double c; //8</div><div>10</div><div>char p2; //1</div><div>11</div><div>};</div><div><span style="font-weight: 400;">&nbsp; &nbsp; &nbsp; sizeof(B);&nbsp; //16</span></div><div><span style="font-weight: bold;">如果你的第一反应是24那么你就躺着中枪了。想想为什么吧！！</span></div><div><span style="font-weight: 400;">因为Union A并没有用来定义任何变量,所以不占用空间.B的实际大小是double的8+char的1=9,再补齐成8的倍数,结果是16.</span></div><div><span style="font-weight: 400;">附件：在GCC中示例代码</span></div><div><br clear="none"/></div><div>1</div><div>#include &quot;stdio.h&quot;</div><div>2</div><div><br clear="none"/></div><div>3</div><div>typedef struct BB</div><div>4</div><div>{</div><div>5</div><div>union AA //没有typedef</div><div>6</div><div>{</div><div>7</div><div>int t; //4</div><div>8</div><div>short m; //2</div><div>9</div><div>char p; //1</div><div>10</div><div>} AA;</div><div>11</div><div>double c; //8</div><div>12</div><div>char p2; //1</div><div>13</div><div>}BB;</div><div>14</div><div><br clear="none"/></div><div>15</div><div>typedef union A //有typedef</div><div>16</div><div>{</div><div>17</div><div>int t; //4</div><div>18</div><div>short m; //2</div><div>19</div><div>char p; //1</div><div>20</div><div>}A;</div><div>21</div><div><br clear="none"/></div><div>22</div><div>typedef struct B</div><div>23</div><div>{</div><div>24</div><div>A a; //4</div><div>25</div><div>double c; //8</div><div>26</div><div>char p2; //1</div><div>27</div><div>}B;</div><div>28</div><div><br clear="none"/></div><div>29</div><div><br clear="none"/></div><div>30</div><div>int main()</div><div>31</div><div>{</div><div>32</div><div>printf(&quot;BB:%d\n&quot;,sizeof(BB));</div><div>33</div><div>printf(&quot;B:%d\n&quot;,sizeof(B));</div><div>34</div><div>return 0;</div><div>35</div><div>}</div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><br clear="none" style="outline: 0px; box-sizing: border-box; word-break: break-all;"/></div><div><br clear="none"/></div><div style="clear: both;"/><div><br/></div><div><h1><span style="font-weight: 700;">一、pragma简介与使用：</span></h1><h2><span style="font-weight: 700;">1、# pragma pack(n)是什么？</span></h2><div><span style="font-weight: 400;">我们知道“32位机对齐（默认）是按4字节对齐，而64位机（默认）是按8字节对齐”加上了“默认”的说明。其实就是说对齐方式在不同机器上是可以修改的，而不同的机器默认的值不一样，但是都是2的整数次幂。如32位机默认为4字节对齐（4*8=32），64位机默认为8字节对齐（8*8=64）。</span></div><div><span style="font-weight: 400;">那么如何修改默认的对齐方式呢，就会用到一个预处理# pragma pack(n)。其中n为可变量，值可取成1,2,4,8.都是2的整数次幂。只要在结构体之前加上# pragma pack(n)自行设定n的值就可以修改对齐方式。# pragma pack(n)包含在stdio.h头文件中。</span></div><div><span style="font-weight: 400;">其实上面说机器是多少位不准确，而应该说是编译器的对齐方式是多少位，VC++6.0默认是8字节对齐，查看具体设置如下所示：</span></div><div><span style="font-weight: 400;"><en-media hash="09c6843131dcbe4360cc2293660b5721" height="178" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="575"/></span></div><h2><span style="font-weight: 700;">2、举例说明（64位）：</span></h2><h3><span style="font-weight: 700;">（1）、# pragma pack(1)：</span></h3><div><span style="font-weight: 400;">按1个字节对齐：所有类型的变量自身所占字节数都是对齐方式的倍数，无需补齐，故结构体的字节数就是所有变量的字节数之和。1+8+4=13个。</span></div><div><span style="font-weight: 400;"><en-media hash="dd3ea1a3dd6f6313ac89534741d57f4f" height="295" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="402"/></span></div><h3><span style="font-weight: 700;">（2）、# pragma pack(2)：</span></h3><div><span style="font-weight: 400;">按2个字节对齐：变量a只需补一个字节便可凑够2字节；变量b占8个字节，为对齐方式的4倍（整数倍），自行对齐，无需补齐；变量c占4个字节，2倍（整数倍）,自行对齐，无需补齐.（1+1）+（2+2+2+2）+（2+2）=14个</span></div><div><span style="font-weight: 400;"><en-media hash="c58aab7d5106a10bfecda702bd27ed37" height="283" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="383"/></span></div><h3><span style="font-weight: 700;">（3）、# pragma pack(4)：</span></h3><div>char a;//自身占用1个，补齐3个，凑足4个对齐</div><div>doube b;//自身占用8个，是4的整数倍数，已经对齐，无需补齐。</div><div>int c;//自身占用4个，是4的整数倍数，已经对齐，无需补齐。</div><div>(1+3)+8+4=16个</div><div>1</div><div>2</div><div>3</div><div>4</div><div><span style="font-weight: 400;"><en-media hash="878ea45ba6d06c6d9c5301f8cba094cb" height="292" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="417"/></span></div><h3><span style="font-weight: 700;">（4）、# pragma pack(8)：</span></h3><div>char a;//自身占用1个，补齐7个，凑足8个对齐</div><div>doube b;//自身占用8个，是8的整数倍数，已经对齐，无需补齐。</div><div>int c;//自身占用4个，补齐4个，凑足8个对齐</div><div>(1+7)+8+(4+4)=24个</div><div>1</div><div>2</div><div>3</div><div>4</div><div><span style="font-weight: 400;"><en-media hash="7f186eda7715d81662d089fd0d1f5c55" height="292" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="395"/></span></div><h3><span style="font-weight: 700;">（5）、# pragma pack()：</span></h3><div><span style="font-weight: 400;">默认值为8，故和# pragma pack(8)的结果相同。</span></div><div><span style="font-weight: 400;"><en-media hash="ffa62bcc3c34b1725df5ce32f52541d4" height="292" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="363"/></span></div><h2><span style="font-weight: 700;">3、恢复默认对齐方式：</span></h2><div><span style="font-weight: 400;">由上可知，结构体的大小是#pragma pack(n)中n的整数倍(该结论有待进一步证明)，要改回默认，只需要在结构体之后加上# pragma pack()即可，不加# pragma pack()，则之前的改变的# pragma pack(n)持续有效。我们可以看出X64的默认值为8字节对齐，而x86默认为4字节对齐：</span></div><h3><span style="font-weight: 700;">（1）、64位：</span></h3><div><span style="font-weight: 400;"><en-media hash="4d9b2f805700f71633b533161176bf3c" height="405" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="422"/></span></div><h3><span style="font-weight: 700;">（2）、32位：</span></h3><div><span style="font-weight: 400;"><en-media hash="821a17f184d2cf91fca25a19ace918be" height="407" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="470"/></span></div><h1><span style="font-weight: 700;">二、注意与反思：</span></h1><div><span style="font-weight: 400;">如果以上所有结论均正确的话，那么下面这个例子将打破不可战胜的神话：</span></div><div><span style="font-weight: 400;"><en-media hash="fc1a9ecf391e85d50e335f9750c03b29" height="363" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="437"/></span></div><div><span style="font-weight: 400;"><en-media hash="99c92f11dd2c21d9c64a9c6dd0d356a3" height="362" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="426"/></span></div><div><span style="font-weight: 400;"><en-media hash="33eb1ea830ca96785a99fafbda94ad77" height="383" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="468"/></span></div><div><span style="font-weight: 400;"><en-media hash="64c5e4b9041cad4ceb7ce770e115fa6a" height="366" style="outline:0px;box-sizing:border-box;margin:24px 0px;word-break:break-all;max-width:100%;cursor:zoom-in;" type="image/png" width="462"/></span></div><div><span style="font-weight: 400;">观察该例，如果按照上述所说形式，仅仅以对齐方式的正整数倍为限定的话，那么这四张图的输出结果应该分别为：</span></div><div>括号中为为了满足是对齐方式的整数倍而补得字节数</div><div>pack(4):4+4+8+4+2+9+1+1+1+（2）=36</div><div>pack(8):4+4+8+4+2+9+1+1+1+（6）=40</div><div>pack(4):4+4+4+2+9+1+1+1+（2）=28</div><div>pack(8):4+4+4+2+9+1+1+1+（6）=32</div><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><h2><span style="font-weight: 700;">1、分析：</span></h2><div><span style="font-weight: 400;">而测试结果为：36、40、28、28；最后一张图输出结果与所谓的理论不符合。</span></div><div><span style="font-weight: 400;">问题何在？显然是所谓的规则有问题：</span></div><div><span style="font-weight: 400;">其实，在结构体中，占字节数最大的变量类型，其占字节数为m（m是2的非负整数次幂）；而#pragma pack(n)中的n（n也是2的非负整数次幂）。</span></div><div><span style="font-weight: 400;">当n&lt;=m时，上述的规则完全适合。</span></div><div><span style="font-weight: 400;">当n&gt;m时，上述的所谓的规则就不一定适合了。</span></div><div><span style="font-weight: 400;">拿此例来说：</span></div><div><span style="font-weight: 400;">前两张图double占用8个字节（m=8），而#pragma pack(4)和#pragma pack(8)的n都不大于m，所以double在满足n的倍数的同时也为满足了 m的倍数。而后两张图中将double类型注释掉以后，最大类型占用4个字节（m=4），在#pragma pack(4)时，n=m,则依然满足，但是在#pragma pack(8)时，n&gt;m，就不再满足是n的整数倍了，而是m的倍数。</span></div><h2><span style="font-weight: 700;">2、准确的描述：</span></h2><div><span style="font-weight: 400;">最根本的其实是满足了n的倍数，却不一定满足m的倍数，满足了m的倍数，不一定满足n的倍数。有可能m，n的倍数都满足，那么到底是谁的倍数呢？</span></div><div><span style="font-weight: 700;">准确的描述为：</span></div><div><span style="font-weight: 700;">（2）、补齐原则：当结构体中，占字节最多的变量所占字节个数大于等于n时，结构体占用字节数的总数是n的倍数；而当结构体中占用字节数最多的变量所占字节数小于n时，结构体占用总字节数是该变量的整数倍。（即结构体占用总字节数是min（m，n）的倍数）</span></div><div><span style="font-weight: 700;">（2）、对齐原则：当前字节数必须是min（m，n）的整数倍。</span></div><div><span style="font-weight: 700;">（3）、min（m，n）是关键！！补齐或对齐原则中所增加的空闲字节个数为：0~min（m，n）-1</span></div><div><span style="font-weight: 400;">举例说明：</span></div><div># pragma pack(2)</div><div>struct node</div><div>{</div><div>char a;</div><div>int b;</div><div>};</div><div>//char已分配1个字节不是int的倍数，若要补3个字节，使得已分配（1）的加上补上的（3），总共4个字节是int的整数倍，而使得int向前四个对齐，那就大错特错了。</div><div>//正确的应该是：因为int在逻辑上也被# pragma pack(2)分成2块，一块为2个字节。所以int应该向2对齐，所以char类型只需要补一个即可。</div><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div><span style="font-weight: 400;">将# pragma pack(n)的使用与结构体内存对齐结合起来，会对二者的理解都有极大地帮助。此外，# pragma pack(n)的n只能是2的非负整数倍（1，2，4，8），并且n大于机器默认值时无效，比如32位默认4字节对齐，即使# pragma pack(8)，依旧是按照4字节对齐。这里只是按个人理解作出描述。</span></div><div><span style="font-weight: 400;">另外还有一点，</span><span style="font-weight: 700;">结构体嵌套原则：如果结构体a中有结构体b的变量，则b在满足作为a的一个成员的补齐对齐原则之外，还要满足b的变量在a中要从b所包含成员的最大类型的整数倍开始存储。</span></div></div><div><br/></div><div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><colgroup><col/></colgroup><tbody><tr><td><h1>有关于__align（n） ，内存对齐 - xidongs - 博客园</h1><div><br/></div></td></tr></tbody></table><div><br/></div></div><div><h1><a href="https://www.cnblogs.com/xidongs/p/5655440.html" style="font-weight: bold; text-decoration: none;">有关于__align（n） ，内存对齐</a></h1></div><div style="margin:0px;padding:0px;clear:both;"/><div>__align</div><div>__align 关键字指示编译器在 <span style="font-style: italic;">n</span> 字节边界上对齐变量。</div><div>__align 是一个存储类修饰符。它不影响函数的类型。</div><div><h4><span style="font-weight: bold;">语法</span></h4></div><div>__align(<span style="font-style: italic;">n</span>)</div><div>其中：</div><div><dl><dt><span style="font-style: italic;">n</span></dt><dd><div>是对齐边界。</div><div>对于局部变量，<span style="font-style: italic;">n</span> 值可为 1、2、4 或 8。</div><div>对于全局变量，<span style="font-style: italic;">n</span> 可以具有最大为 2 的 0x80000000 次幂的任何值。</div><div>__align 关键字紧靠变量名称前面放置。</div></dd></dl></div><div><h4><span style="font-weight: bold;">用法</span></h4></div><div>如果声明的变量的常规对齐边界小于 <span style="font-style: italic;">n</span>，__align(<span style="font-style: italic;">n</span>) 是非常有用的。八字节对齐方式可以显著提高 VFP 指令的性能。</div><div>可以将 __align 与&nbsp;extern 和 static 一起使用。</div><div><h4><span style="font-weight: bold;">限制</span></h4></div><div>由于 __align 是存储类修饰符，因此不能将其用于：</div><div><ul compact="compact" type="disc"><li><div>类型，包括 typedef 和结构定义</div></li><li><div>函数参数。</div></li></ul></div><div>只能进行过对齐。也就是说，可以将两个字节的对象按 4 个字节对齐，而不能将 4 个字节的对象按两个字节对齐。</div><div><h4><span style="font-weight: bold;">示例</span></h4></div><div>__align(8) char buffer[128]; &nbsp;// buffer starts on eight-byte boundary</div><div>void foo(void)</div><div>{</div><div>&nbsp; &nbsp;...</div><div>&nbsp; &nbsp;__align(16) int i; // this alignment value is not permitted for</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // a local variable</div><div>&nbsp; &nbsp;...</div><div>}</div><div><br/></div><div>__align(16) int i; // permitted as a global variable.</div><div>-----------------------------------------------------------------------------------------------------------------------------------------------------</div><div>-----------------------------------------------------------------------------------------------------------------------------------------------------</div><div>一.什么是字节对齐,为什么要对齐?</div><div>&nbsp;&nbsp; 现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</div><div>&nbsp;&nbsp; 对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。</div><div>二.字节对齐对程序的影响:</div><div>&nbsp;&nbsp; 先让我们看几个例子吧(32bit,x86环境,gcc编译器):</div><div>设结构体如下定义：</div><div>struct A</div><div>{</div><div>&nbsp;&nbsp; int a;</div><div>&nbsp;&nbsp; char b;</div><div>&nbsp;&nbsp; short c;</div><div>};</div><div>struct B</div><div>{</div><div>&nbsp;&nbsp; char b;</div><div>&nbsp;&nbsp; int a;</div><div>&nbsp;&nbsp; short c;</div><div>};</div><div>现在已知32位机器上各种数据类型的长度如下:</div><div>char:1(有符号无符号同) &nbsp; &nbsp;</div><div>short:2(有符号无符号同) &nbsp; &nbsp;</div><div>int:4(有符号无符号同) &nbsp; &nbsp;</div><div>long:4(有符号无符号同) &nbsp; &nbsp;</div><div>float:4 &nbsp;&nbsp; double:8</div><div>那么上面两个结构大小如何呢?</div><div>结果是:</div><div>sizeof(strcut A)值为8</div><div>sizeof(struct B)的值却是12</div><div>结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样;按理说A,B大小应该都是7字节。</div><div>之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果,那么我们是不是可以改变编译器的这种默认对齐设置呢,当然可以.例如:</div><div>#pragma pack (2) /*指定按2字节对齐*/</div><div>struct C</div><div>{</div><div>&nbsp;&nbsp; char b;</div><div>&nbsp;&nbsp; int a;</div><div>&nbsp;&nbsp; short c;</div><div>};</div><div>#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div>sizeof(struct C)值是8。</div><div>修改对齐值为1：</div><div>#pragma pack (1) /*指定按1字节对齐*/</div><div>struct D</div><div>{</div><div>&nbsp;&nbsp; char b;</div><div>&nbsp;&nbsp; int a;</div><div>&nbsp;&nbsp; short c;</div><div>};</div><div>#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div>sizeof(struct D)值为7。</div><div>后面我们再讲解#pragma pack()的作用.</div><div>三.编译器是按照什么样的原则进行对齐的?</div><div>&nbsp;&nbsp; 先让我们看四个重要的基本概念：</div><div>1.数据类型自身的对齐值：</div><div>对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。</div><div>2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</div><div>3.指定对齐值：#pragma pack (value)时的指定对齐值value。</div><div>4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</div><div>有 了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在N上”，也就是说该数据的&quot;存放起始地址%N=0&quot;.而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数 据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</div><div>例子分析：</div><div>分析例子B；</div><div>struct B</div><div>{</div><div>&nbsp;&nbsp; char b;</div><div>&nbsp;&nbsp; int a;</div><div>&nbsp;&nbsp; short c;</div><div>};</div><div>假 设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定 对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4， 所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为 2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的 都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节,sizeof(struct B)=12;其实如果就这一个就来说它已将满足字节对齐了, 因为它的起始地址是0,因此肯定是对齐的,之所以在后面补充2个字节,是因为编译器为了实现结构数组的存取效率,试想如果我们定义了一个结构B的数组,那 么第一个结构起始地址是0没有问题,但是第二个结构呢?按照数组的定义,数组中所有元素都是紧挨着的,如果我们不把结构的大小补充为4的整数倍,那么下一 个结构的起始地址将是0x0000A,这显然不能满足结构的地址对齐了,因此我们要把结构补充成有效对齐大小的整数倍.其实诸如:对于char型数据，其 自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的,只 是因为这些类型的长度已知了,所以他们的自身对齐值也就已知了.</div><div>同理,分析上面例子C：</div><div>#pragma pack (2) /*指定按2字节对齐*/</div><div>struct C</div><div>{</div><div>&nbsp;&nbsp; char b;</div><div>&nbsp;&nbsp; int a;</div><div>&nbsp;&nbsp; short c;</div><div>};</div><div>#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div>第 一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1= 0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续 字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放</div><div>在0x0006、0x0007中，符合 0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C 只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8.</div><div>四.如何修改编译器的默认对齐值?</div><div>1.在VC IDE中，可以这样修改：[Project]|[Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</div><div>2.在编码时，可以这样动态修改：#pragma pack .注意:是pragma而不是progma.</div><div>五.针对字节对齐,我们在编程中如何考虑?</div><div>&nbsp;&nbsp; 如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0,然后各个变量按照上面的原则进行排列即可,基本的原则就是把结构中的变量按照 类型大小从小到大声明,尽量减少中间的填补空间.还有一种就是为了以空间换取时间的效率,我们显示的进行填补空间进行对齐,比如:有一种使用空间换时间做 法是显式的插入reserved成员：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; struct A{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char a;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char reserved[3];//使用空间换时间</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int b;</div><div>}</div><div>reserved成员对我们的程序没有什么意义,它只是起到填补空间以达到字节对齐的目的,当然即使不加这个成员通常编译器也会给我们自动填补对齐,我们自己加上它只是起到显式的提醒作用.</div><div>六.字节对齐可能带来的隐患:</div><div>&nbsp;&nbsp; 代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：</div><div>unsigned int i = 0x12345678;</div><div>unsigned char *p=NULL;</div><div>unsigned short *p1=NULL;</div><div>p=&amp;i;</div><div>*p=0x00;</div><div>p1=(unsigned short *)(p+1);</div><div>*p1=0x0000;</div><div>最后两句代码，从奇数边界去访问unsignedshort型变量，显然不符合对齐的规定。</div><div>在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error,因为它们要求必须字节对齐.</div><div>七.如何查找与字节对齐方面的问题:</div><div>如果出现对齐或者赋值问题首先查看</div><div>1. 编译器的big little端设置</div><div>2. 看这种体系本身是否支持非对齐访问</div><div>3. 如果支持看设置了对齐与否,如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</div><div>八.ARM下的对齐处理</div><div>from DUI0067D_ADS1_2_CompLib</div><div>3.13 type qulifiers</div><div>有部分摘自ARM编译器文档对齐部分</div><div>对齐的使用:</div><div>1.__align(num)</div><div>&nbsp; 这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时</div><div>&nbsp; 就要用到此命令__align(8)进行修饰限制。来保证数据对象是相应对齐。</div><div>&nbsp; 这个修饰对象的命令最大是8个字节限制,可以让2字节的对象进行4字节</div><div>&nbsp; 对齐,但是不能让4字节的对象2字节对齐。</div><div>&nbsp; __align是存储类修改,他只修饰最高级类型对象不能用于结构或者函数对象。</div><div>&nbsp;</div><div>2.__packed</div><div>__packed是进行一字节对齐</div><div>1.不能对packed的对象进行对齐</div><div>2.所有对象的读写访问都进行非对齐访问</div><div>3.float及包含float的结构联合及未用__packed的对象将不能字节对齐</div><div>4.__packed对局部整形变量无影响</div><div>5.强制由unpacked对象向packed对象转化是未定义,整形指针可以合法定</div><div>义为packed。</div><div>&nbsp; &nbsp; __packed int* p; //__packed int 则没有意义</div><div>6.对齐或非对齐读写访问带来问题</div><div>__packed struct STRUCT_TEST</div><div>{</div><div>char a;</div><div>int b;</div><div>char c;</div><div>} ; &nbsp;&nbsp; //定义如下结构此时b的起始地址一定是不对齐的</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from CL]</div><div>//将下面变量定义成全局静态不在栈上</div><div>static char* p;</div><div>static struct STRUCT_TEST a;</div><div>void Main()</div><div>{</div><div>__packed int* q; //此时定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</div><div>p = (char*)&amp;a; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>q = (int*)(p+1); &nbsp; &nbsp; &nbsp;</div><div><br style="margin:0px;padding:0px;"/></div><div>*q = 0x87654321;</div><div>/* &nbsp;</div><div>得到赋值的汇编指令很清楚</div><div>ldr &nbsp; &nbsp;&nbsp; r5,0x20001590 ; = #0x12345678</div><div>[0xe1a00005] &nbsp; mov &nbsp; &nbsp;&nbsp; r0,r5</div><div>[0xeb0000b0] &nbsp; bl &nbsp; &nbsp; &nbsp; __rt_uwrite4 //在此处调用一个写4byte的操作函数</div><div>&nbsp; &nbsp; &nbsp;</div><div>[0xe5c10000] &nbsp; strb &nbsp; &nbsp; r0,[r1,#0] &nbsp; //函数进行4次strb操作然后返回保证了数据正确的访问</div><div>[0xe1a02420] &nbsp; mov &nbsp; &nbsp;&nbsp; r2,r0,lsr #8</div><div>[0xe5c12001] &nbsp; strb &nbsp; &nbsp; r2,[r1,#1]</div><div>[0xe1a02820] &nbsp; mov &nbsp; &nbsp;&nbsp; r2,r0,lsr #16</div><div>[0xe5c12002] &nbsp; strb &nbsp; &nbsp; r2,[r1,#2]</div><div>[0xe1a02c20] &nbsp; mov &nbsp; &nbsp;&nbsp; r2,r0,lsr #24</div><div>[0xe5c12003] &nbsp; strb &nbsp; &nbsp; r2,[r1,#3]</div><div>[0xe1a0f00e] &nbsp; mov &nbsp; &nbsp;&nbsp; pc,r14</div><div>*/</div><div>/*</div><div>如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败</div><div>[0xe59f2018] &nbsp; ldr &nbsp; &nbsp;&nbsp; r2,0x20001594 ; = #0x87654321</div><div>[0xe5812000] &nbsp; str &nbsp; &nbsp;&nbsp; r2,[r1,#0]</div><div>*/</div><div>//这样可以很清楚的看到非对齐访问是如何产生错误的</div><div>//以及如何消除非对齐访问带来问题</div><div>//也可以看到非对齐访问和对齐访问的指令差异导致效率问题</div><div>}</div><div>九.ARM下的边界未对齐访问的后果</div><div>from <a href="http://blog.csdn.net/alenwelkin/archive/2006/12/19/1448324.aspx" style="text-decoration: underline;">http://blog.csdn.net/alenwelkin/archive/2006/12/19/1448324.aspx</a></div><div><br style="margin:0px;padding:0px;"/></div><div>自行编写了一个程序，定义一个char型数组如下：</div><div>char p[] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80};</div><div>分别用long型和short型指针去指向p+3的位置，这个地址在编译后是0x10963，明显是一个对long和short来说都不对齐的地址。</div><div>程序输出结果如下，括号里为内容，前面是地址。</div><div>/mnt ＄ ./test</div><div>l 0x10963(0x30201040), s 0x10963(0x5040), lt 0x30201040, st 0x5040</div><div>使用arm-linux-objdump工具反汇编可执行文件发现，对于short指针的引用，编译器做了特殊处理以保证其引用的正确性，而long指针没有做。</div><div>unsigned long *l = (p + 3);</div><div>&nbsp;&nbsp; 83e0: e59f3084 ldr r3, [pc, #132] ; 846c &lt;.text+0x190&gt;</div><div>&nbsp;&nbsp; 83e4: e50b3010 str r3, [fp, #-16]</div><div>unsigned short *s = (p + 3);</div><div>&nbsp;&nbsp; 83e8: e59f307c ldr r3, [pc, #124] ; 846c &lt;.text+0x190&gt;</div><div>&nbsp;&nbsp; 83ec: e50b3014 str r3, [fp, #-20]</div><div>unsigned long lt = *l;</div><div>&nbsp;&nbsp; 83f0: e51b3010 ldr r3, [fp, #-16] //变量l-&gt;r3</div><div>&nbsp;&nbsp; 83f4: e5933000 ldr r3, [r3] //l内容-&gt;r3</div><div>&nbsp;&nbsp; 83f8: e50b3018 str r3, [fp, #-24] //r3-&gt;lt</div><div>unsigned short st = *s;</div><div>&nbsp;&nbsp; 83fc: e51b3014 ldr r3, [fp, #-20] //变量s-&gt;r3</div><div>&nbsp;&nbsp; 8400: e5d32000 ldrb r2, [r3] //s内容（低位）-&gt;r2</div><div>&nbsp;&nbsp; 8404: e5d33001 ldrb r3, [r3, #1] //s内容（高位）-&gt;r3</div><div>&nbsp;&nbsp; 8408: e1823403 orr r3, r2, r3, lsl #8 //r3左移后与r2拼合成short值-&gt;r3</div><div>&nbsp;&nbsp; 840c: e54b301a strb r3, [fp, #-26] //r3中的short值(低位)-&gt;变量st低位</div><div>&nbsp;&nbsp; 8410: e1a03443 mov r3, r3, asr #8 //r3右移8位-&gt;r3</div><div>&nbsp;&nbsp; 8414: e54b3019 strb r3, [fp, #-25] //r3中的short值(高位)-&gt;变量st高位</div><div>0x30201040是怎么来的？想了半天也不明白。</div><div>查 阅ARM相关书籍发现，如果协处理器CP15:c1:c0中的1位和22位均为0，则ARM指令ldr的返回值是memory(addr &amp; ~3, 4) ROR ((addr &amp; 3) * 8)。前半句的含义是对4边界向下取整，在本例中就是0x10960，再取其内容就是 0x40302010，后半句在本例中是循环右移24位。合起来看就是0x40302010 ROR 24 ＝ 0x30201040，与本例正好吻合！</div><div><br/></div><div style="margin:0px;padding:0px;clear:both;"/><div><colgroup><col/></colgroup><div><br/></div></div><div><h1><a href="https://www.cnblogs.com/embedded-linux/p/5801999.html" style="font-weight: bold; text-decoration: none;">C之attribute用法</a></h1><div style="margin:0px;padding:0px;clear:both;"/><div><div>转自：http://www.cnblogs.com/astwish/p/3460618.html</div><div>GNU C 的一大特色就是__attribute__ 机制。__attribute__ 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。</div><div>__attribute__ 书写特征是：__attribute__ 前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的__attribute__ 参数。</div><div>__attribute__ 语法格式为：__attribute__ ((attribute-list))</div><div>其位置约束为：放于声明的尾部“ ；” 之前。</div><div>关键字__attribute__ 也可以对结构体（struct ）或共用体（union ）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和&nbsp;may_alias 。</div><div>在使用__attribute__ 参数时，你也可以在参数的前后都加上“__” （两个下划线），例如，使用__aligned__而不是aligned ，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</div><div><span lang="EN-US" style="font-weight: bold;" xml:lang="EN-US">aligned (alignment)</span></div><div>该属性设定一个指定大小的对齐格式（以字节 为单位），例如：</div><div>struct S {</div><div>short b[3];</div><div>} __attribute__ ((aligned (8)));</div><div>typedef int int32_t __attribute__ ((aligned (8)));</div><div>该声明将强制编译器确保（尽它所能）变量类 型为struct S 或者int32_t 的变量在分配空间时采用8 字节对齐方式。</div><div>如上所述，你可以手动指定对齐的格式，同 样，你也可以使用默认的对齐方式。如果aligned 后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如：</div><div>struct S {</div><div>short b[3];</div><div>} __attribute__ ((aligned));</div><div>这里，如果sizeof （short ）的大小为2 （byte ），那么，S 的大小就为6 。取一个2 的次方值，使得该值大于等于6 ，则该值为8 ，所以编译器将设置S 类型的对齐方式为8 字节。</div><div>aligned 属性使被设置的对象占用更多的空间，相反的，使用packed 可以减小对象占用的空间。</div><div>需要注意的是，attribute 属性的效力与你的连接器也有关，如果你的连接器最大只支持16 字节对齐，那么你此时定义32 字节对齐也是无济于事的。</div><div><span lang="EN-US" style="font-weight: bold;" xml:lang="EN-US">packed</span></div><div>&nbsp;使用该属性对struct 或者union 类型进行定义，设定其类型的每一个变量的内存约束。当用在enum 类型 定义时，暗示了应该使用最小完整的类型（it indicates that the smallest integral type should be used）。</div><div>&nbsp;下面的例子中，packed_struct 类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s 不会被“pack” ，如果希望内部的成员变量也被packed 的话，unpacked-struct 也需要使用packed 进行相应的约束。</div><div>struct unpacked_struct</div><div>{</div><div>&nbsp; &nbsp; &nbsp;char c;</div><div>&nbsp; &nbsp; &nbsp;int i;</div><div>};</div><div>&nbsp; &nbsp; &nbsp; &nbsp;</div><div>struct packed_struct</div><div>{</div><div>&nbsp; &nbsp; char c;</div><div>&nbsp; &nbsp; int &nbsp;i;</div><div>&nbsp; &nbsp; struct unpacked_struct s;</div><div>}__attribute__ ((__packed__));</div><div>下面的例子中使用__attribute__ 属性定义了一些结构体及其变量，并给出了输出结果和对结果的分析。</div><div>程序代 码为：</div><div><a href="http://loadhtml/#" style="text-decoration: none;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div><span style="text-decoration: none;"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/gif" width="20"/></span></div><div>1 struct p</div><div>2</div><div>3 {</div><div>4</div><div>5 int a;</div><div>6</div><div>7 char b;</div><div>8</div><div>9 short c;</div><div>10</div><div>11 }__attribute__((aligned(4))) pp;</div><div>12</div><div>13 struct m</div><div>14</div><div>15 {</div><div>16</div><div>17 char a;</div><div>18</div><div>19 int b;</div><div>20</div><div>21 short c;</div><div>22</div><div>23 }__attribute__((aligned(4))) mm;</div><div>24</div><div>25 struct o</div><div>26</div><div>27 {</div><div>28</div><div>29 int a;</div><div>30</div><div>31 char b;</div><div>32</div><div>33 short c;</div><div>34</div><div>35 }oo;</div><div>36</div><div>37 struct x</div><div>38</div><div>39 {</div><div>40</div><div>41 int a;</div><div>42</div><div>43 char b;</div><div>44</div><div>45 struct p px;</div><div>46</div><div>47 short c;</div><div>48</div><div>49 }__attribute__((aligned(8))) xx;</div><div>50</div><div>51 int main()</div><div>52</div><div>53 {</div><div>54</div><div>55 printf(&quot;sizeof(int)=%d,sizeof(short)=%d.sizeof(char)=%d\n&quot;,sizeof(int),sizeof(short),sizeof(char));</div><div>56</div><div>57 printf(&quot;pp=%d,mm=%d \n&quot;, sizeof(pp),sizeof(mm));</div><div>58</div><div>59 printf(&quot;oo=%d,xx=%d \n&quot;, sizeof(oo),sizeof(xx));</div><div>60</div><div>61 return 0;</div><div>62</div><div>63 }</div><div><span style="text-decoration: none;"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/gif" width="20"/></span></div><div><a href="http://loadhtml/#" style="text-decoration: none;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>输出结 果：</div><div>sizeof(int)=4,sizeof(short)=2.sizeof(char)=1</div><div>pp=8,mm=12</div><div>oo=8,xx=24</div><div>分析：</div><div>sizeof(pp):</div><div>sizeof(a)+sizeof(b)+sizeof(c)=4+1+1=6&lt;8 所以sizeof(pp)=8</div><div>sizeof(mm):</div><div>sizeof(a)+sizeof(b)+sizeof(c)=1+4+2=7</div><div>但是 a 后面需要用 3 个字节填充，但是 b 是&nbsp;4 个字节，所以 a 占用 4 字节， b 占用 4 个字节，而 c 又要占用 4 个字节。所以 sizeof(mm)=12</div><div>sizeof(oo):</div><div>sizeof(a)+sizeof(b)+sizeof(c)=4+1+2=7</div><div>因为默 认是以4 字节对齐，所以sizeof(oo)=8</div><div align="left">sizeof(xx):</div><div align="left">sizeof(a)+ sizeof(b)=4+1=5</div><div align="left">sizeof(pp)=8; 即xx 是采用8 字节对齐的，所以要在a ，b 后面添3 个空余字节，然后才能存储px ，</div><div align="left">4+1+ （3 ）+8+1=17</div><div align="left">因为xx 采用的对齐是8 字节对齐，所以xx 的大小必定是8 的整数倍，即xx 的大小是一个比17 大又是8 的倍数的一个最小值，由此得到</div><div align="left">17&lt;24 ，所以sizeof(xx)=24</div><div><span style="font-weight: bold;">函数属性（Function Attribute）</span></div><div>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。__attribute__机制也很容易同非GNU应用程序做到兼容之功效。</div><div>GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。</div><div>__attribute__ format</div><div>该__attribute__属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。</div><div>format的语法格式为：</div><div>format (archetype, string-index, first-to-check)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; format属性告诉编译器，按照printf, scanf,</div><div>strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。</div><div>具体使用格式如下：</div><div>__attribute__((format(printf,m,n)))</div><div>__attribute__((format(scanf,m,n)))</div><div>其中参数m与n的含义为：</div><div>m：第几个参数为格式化字符串（format string）；</div><div>n：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到；</div><div>在使用上，__attribute__((format(printf,m,n)))是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf：</div><div>//m=1；n=2</div><div>extern void myprint(const char *format,...) __attribute__((format(printf,1,2)));</div><div>//m=2；n=3</div><div>extern void myprint(int l，const char *format,...)</div><div>__attribute__((format(printf,2,3)));</div><div>需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如：</div><div>//m=3；n=4</div><div>extern void myprint(int l，const char *format,...)</div><div>__attribute__((format(printf,3,4)));</div><div>其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？）</div><div>这里给出测试用例：attribute.c，代码如下：</div><div><a href="http://loadhtml/#" style="text-decoration: none;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div><span style="text-decoration: none;"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/gif" width="20"/></span></div><div>1：</div><div>2：extern void myprint(const char *format,...)</div><div>__attribute__((format(printf,1,2)));</div><div>3：</div><div>4：void test()</div><div>5：{</div><div>6： myprint(&quot;i=%d\n&quot;,6);</div><div>7： myprint(&quot;i=%s\n&quot;,6);</div><div>8： myprint(&quot;i=%s\n&quot;,&quot;abc&quot;);</div><div>9： myprint(&quot;%s,%d,%d\n&quot;,1,2);</div><div>10：}</div><div><span style="text-decoration: none;"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/gif" width="20"/></span></div><div><a href="http://loadhtml/#" style="text-decoration: none;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>运行$gcc –Wall –c attribute.c attribute后，输出结果为：</div><div><br style="margin:0px;padding:0px;"/></div><div>attribute.c: In function `test&apos;:</div><div>attribute.c:7: warning: format argument is not a pointer (arg 2)</div><div>attribute.c:9: warning: format argument is not a pointer (arg 2)</div><div>attribute.c:9: warning: too few arguments for format</div><div><br style="margin:0px;padding:0px;"/></div><div>如果在attribute.c中的函数声明去掉__attribute__((format(printf,1,2)))，再重新编译，既运行$gcc –Wall –c attribute.c attribute后，则并不会输出任何警告信息。</div><div>注意，默认情况下，编译器是能识别类似printf的“标准”库函数。</div><div>__attribute__ noreturn</div><div>该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的abort（）和exit（）的声明格式就采用了这种格式，如下所示：</div><div><br style="margin:0px;padding:0px;"/></div><div>extern void exit(int) &nbsp; &nbsp;&nbsp; __attribute__((noreturn));extern void abort(void) __attribute__((noreturn)); 为了方便理解，大家可以参考如下的例子：</div><div><a href="http://loadhtml/#" style="text-decoration: none;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div><span style="text-decoration: none;"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/gif" width="20"/></span></div><div>1 //name: noreturn.c ；测试__attribute__((noreturn))</div><div>2 extern void myexit();</div><div>3</div><div>4 int test(int n)</div><div>5 {</div><div>6 if ( n &gt; 0 )</div><div>7 {</div><div>8 myexit();</div><div>9 /* 程序不可能到达这里*/</div><div>10 }</div><div>11 else</div><div>12 return 0;</div><div>13 }</div><div><span style="text-decoration: none;"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/gif" width="20"/></span></div><div><a href="http://loadhtml/#" style="text-decoration: none;" title="复制代码"><en-media hash="51e409b11aa51c150090697429a953ed" height="20" style="margin:0px;padding:0px;height:auto;max-width:300px;border:none;background-color:rgb(245, 245, 245);" type="image/gif" width="20"/></a></div><div>编译显示的输出信息为：</div><div><br style="margin:0px;padding:0px;"/></div><div>$gcc –Wall –c noreturn.c</div><div>noreturn.c: In function `test&apos;:</div><div>noreturn.c:12: warning: control reaches end of non-void function</div><div><br style="margin:0px;padding:0px;"/></div><div>警告信息也很好理解，因为你定义了一个有返回值的函数test却有可能没有返回值，程序当然不知道怎么办了！</div><div>加上__attribute__((noreturn))则可以很好的处理类似这种问题。把</div><div>extern void myexit();修改为：</div><div>extern void myexit() __attribute__((noreturn));之后，编译不会再出现警告信息。</div><div>__attribute__ const</div><div>该属性只能用于带有数值类型参数的函数上。当重复调用带有数值参数的函数时，由于返回值是相同的，所以此时编译器可以进行优化处理，除第一次需要运算外， 其它只需要返回第一次的结果就可以了，进而可以提高效率。该属性主要适用于没有静态状态（static state）和副作用的一些函数，并且返回值仅仅依赖输入的参数。</div><div>为了说明问题，下面举个非常“糟糕”的例子，该例子将重复调用一个带有相同参数值的函数，具体如下：</div><div><br style="margin:0px;padding:0px;"/></div><div>extern int square(int n) __attribute__ &nbsp; &nbsp; ((const));... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for (i = 0; i &lt; 100; i++ ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; { &nbsp; &nbsp; &nbsp; total += square (5) + i; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>通过添加__attribute__((const))声明，编译器只调用了函数一次，以后只是直接得到了相同的一个返回值。</div><div>事实上，const参数不能用在带有指针类型参数的函数中，因为该属性不但影响函数的参数值，同样也影响到了参数指向的数据，它可能会对代码本身产生严重甚至是不可恢复的严重后果。</div><div>并且，带有该属性的函数不能有任何副作用或者是静态的状态，所以，类似getchar（）或time（）的函数是不适合使用该属性的。</div><div>-finstrument-functions</div><div>该参数可以使程序在编译时，在函数的入口和出口处生成instrumentation调用。恰好在函数入口之后并恰好在函数出口之前，将使用当前函数的地址和调用地址来调用下面的</div><div>profiling</div><div>函数。（在一些平台上，__builtin_return_address不能在超过当前函数范围之外正常工作，所以调用地址信息可能对profiling函数是无效的。）</div><div><br style="margin:0px;padding:0px;"/></div><div>void __cyg_profile_func_enter(void *this_fn, void *call_site);</div><div>void __cyg_profile_func_exit(void *this_fn, void *call_site);</div><div><br style="margin:0px;padding:0px;"/></div><div>其中，第一个参数this_fn是当前函数的起始地址，可在符号表中找到；第二个参数call_site是指调用处地址。</div><div>instrumentation</div><div>也可用于在其它函数中展开的内联函数。从概念上来说，profiling调用将指出在哪里进入和退出内联函数。这就意味着这种函数必须具有可寻址形式。如 果函数包含内联，而所有使用到该函数的程序都要把该内联展开，这会额外地增加代码长度。如果要在C 代码中使用extern inline声明，必须提供这种函数的可寻址形式。</div><div>可对函数指定no_instrument_function属性，在这种情况下不会进行 Instrumentation操作。例如，可以在以下情况下使用no_instrument_function属性：上面列出的profiling函 数、高优先级的中断例程以及任何不能保证profiling正常调用的函数。</div><div>no_instrument_function</div><div>如果使用了-finstrument-functions</div><div>，将在绝大多数用户编译的函数的入口和出口点调用profiling函数。使用该属性，将不进行instrument操作。</div><div>constructor/destructor</div><div>若函数被设定为constructor属性，则该函数会在main（）函数执行之前被自动的执行。类似的，若函数被设定为destructor属性，则该 函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。拥有此类属性的函数经常隐式的用在程序的初始化数据方面。</div><div>这两个属性还没有在面向对象C中实现。</div><div>同时使用多个属性</div><div>可以在同一个函数声明里使用多个__attribute__，并且实际应用中这种情况是十分常见的。使用方式上，你可以选择两个单独的__attribute__，或者把它们写在一起，可以参考下面的例子：</div><div><br style="margin:0px;padding:0px;"/></div><div>/* 把类似printf的消息传递给stderr 并退出 */extern void die(const char *format, ...) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; __attribute__((noreturn)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; __attribute__((format(printf, 1, 2))); 或者写成 extern void die(const char *format, ...) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; __attribute__((noreturn, format(printf, 1, 2))); 如果带有该属性的自定义函数追加到库的头文件里，那么所以调用该函数的程序都要做相应的检查。</div><div><br style="margin:0px;padding:0px;"/></div><div>和非GNU编译器的兼容性</div><div>庆幸的是，__attribute__设计的非常巧妙，很容易作到和其它编译器保持兼容，也就是说，如果工作在其它的非GNU编译器上，可以很容易的忽略该属性。即使__attribute__使用了多个参数，也可以很容易的使用一对圆括弧进行处理，例如：</div><div><br style="margin:0px;padding:0px;"/></div><div>/* 如果使用的是非GNU C, 那么就忽略__attribute__ */#ifndef __GNUC__# &nbsp; &nbsp; define &nbsp; &nbsp; __attribute__(x) &nbsp; &nbsp; /*NOTHING*/#endif</div><div>需要说明的是，__attribute__适用于函数的声明而不是函数的定义。所以，当需要使用该属性的函数时，必须在同一个文件里进行声明，例如：</div><div><br style="margin:0px;padding:0px;"/></div><div>/* 函数声明 */void die(const char *format, ...) __attribute__((noreturn)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __attribute__((format(printf,1,2))); void die(const char *format, ...){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /* 函数定义 */}</div><h3><span style="font-weight: bold;">Specifying Attributes of Variables</span></h3><div><span style="font-weight: bold;">aligned (</span><span style="font-weight: bold;">alignment</span><span style="font-weight: bold;">)</span><span style="font-weight: bold;">This attribute specifies a minimum alignment for the variable or structure field, measured in bytes. For example, the declaration:</span></div><div>int x __attribute__ ((aligned (16))) = 0;</div><div>causes the compiler to allocate the global variable x on a 16-byte boundary. On a 68040, this could be used in conjunction with an asm expression to access themove16 instruction which requires 16-byte aligned operands.</div><div>You can also specify the alignment of structure fields. For example, to create a double-word aligned int pair, you could write:</div><div>struct foo { int x[2] __attribute__ ((aligned (8))); };</div><div>This is an alternative to creating a union with a double member that forces the union to be double-word aligned.</div><div>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</div><div>short array[3] __attribute__ ((aligned));</div><div><span style="font-weight: bold;">for more:</span> <a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes" style="font-weight: bold; text-decoration: none;">http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes</a></div><div>下面来看一个不一样的HelloWorld程序:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;stdio.h&gt;</div><div>#include &lt;stdlib.h&gt;</div><div>static&nbsp;&nbsp;__attribute__((constructor)) void before()</div><div>{</div><div>&nbsp;&nbsp;&nbsp;printf(&quot;Hello&quot;);</div><div>}</div><div>static&nbsp;&nbsp;__attribute__((destructor)) void after()</div><div>{</div><div>&nbsp;&nbsp;&nbsp;printf(&quot; World!\n&quot;);</div><div>}</div><div>int main(int args,char ** argv)</div><div>{</div><div>&nbsp;&nbsp;&nbsp;return EXIT_SUCCESS;</div><div>}</div></div><div><br/></div><div>我们知道这是一个HelloWorld程序，所以输出的结果就是&quot;Hello World!&quot;，很简单，不需要对这点过多关心.<br/></div><div>下面我们来关心关心别的:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>__attribute__((constructor))</div><div>__attribute__((destructor))</div></div><div><br/></div><div><br/></div><div>解释一下：__attribute__((constructor)) 在main() 之前执行,__attribute__((destructor)) 在main()执行结束之后执行.</div><div>上面的例子中我没有在main函数中添加任何的输出，所以看不到具体的信息.这点可以自己尝试～</div><div>如果要在main()之前或者是执行完成之后，需要执行很多的前处理动作或者是后处理动作，我们应该怎么处理?</div><div>也许，你需要下面这些东西:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>__attribute__((constructor(PRIORITY)))</div><div>__attribute__((destructor(PRIORITY)))</div></div><div><br/></div><div>PRIORITY: 优先级.</div><div>好吧，下面就来试试：</div><div><en-media hash="fcf969fa174c52217441f824eb4cb303" height="635" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/png" width="858"/></div><div>执行的输出如下:</div><div><en-media hash="d4c6bc6e7baf0ef573afff6b452d407c" height="161" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/png" width="861"/></div><div>从输出的信息看，前处理都是按照优先级先后执行的，而后处理则是相反的，好吧，我们使用GDB调试验证一下:</div><div><en-media hash="a44da6958788010b6896c2f5b984bdc3" height="573" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/png" width="857"/></div><div>从调试的信息也是验证了上面的结果.</div><div>另外一个问题，优先级有没有范围的？</div><div>其实刚开始我写的程序中的优先级是1,我们将上面的程序改一下，然后编译看一下会有什么样的结果:</div><div><en-media hash="6ac36ee61a33373e31828161e61a3fb5" height="130" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/png" width="860"/></div><div><en-media hash="01a972170b44d6ee3b310c4b8046c93d" height="33" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/png" width="859"/></div><div>0-100(包括100),是内部保留的，所以在编码的时候需要注意.</div><div>关于__attribute__的用法，可以有另外一种写法，先声明函数，然后再定义.</div><div><en-media hash="baee571df6e380a0e0b0bbb747c57df1" height="432" style="margin:0px;padding:0px;border:0px;height:auto;max-width:300px;" type="image/png" width="856"/></div><div>glibc多采用第一种写法.</div><div><span style="font-weight: bold;">关于linux内核中的&quot;__attribute__ ((packed))&quot;</span></div><div>引用:</div><div>__attrubte__ ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐。</div><div>#define __u8 &nbsp;&nbsp; unsigned char</div><div>#define __u16 &nbsp; unsigned short</div><div>/* __attribute__ ((packed)) 的位置约束是放于声明的尾部“；”之前 */</div><div>struct str_struct{</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; a;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; b;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; c;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u16 &nbsp; d;</div><div>} __attribute__ ((packed));</div><div>/*&nbsp; 当用到typedef时，要特别注意__attribute__ ((packed))放置的位置，相当于：</div><div>&nbsp; *&nbsp; typedef struct str_stuct str;</div><div>&nbsp; *&nbsp; 而struct str_struct 就是上面的那个结构。</div><div>&nbsp; */</div><div>typedef struct {</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; a;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; b;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; c;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u16 &nbsp; d;</div><div>} __attribute__ ((packed)) str;</div><div>/* 在下面这个typedef结构中，__attribute__ ((packed))放在结构名str_temp之后，其作用是被忽略的，注意与结构str的区别。*/</div><div>typedef struct {</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; a;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; b;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; c;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u16 &nbsp; d;</div><div>}str_temp __attribute__ ((packed));</div><div>typedef struct {</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; a;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; b;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u8 &nbsp;&nbsp; c;</div><div>&nbsp; &nbsp; &nbsp;&nbsp; __u16 &nbsp; d;</div><div>}str_nopacked;</div><div>int main(void)</div><div>{</div><div>&nbsp; &nbsp; &nbsp;&nbsp; printf(&quot;sizeof str = %d\n&quot;, sizeof(str));</div><div>&nbsp; &nbsp; &nbsp;&nbsp; printf(&quot;sizeof str_struct = %d\n&quot;, sizeof(struct str_struct));</div><div>&nbsp; &nbsp; &nbsp;&nbsp; printf(&quot;sizeof str_temp = %d\n&quot;, sizeof(str_temp));</div><div>&nbsp; &nbsp; &nbsp;&nbsp; printf(&quot;sizeof str_nopacked = %d\n&quot;, sizeof(str_nopacked));</div><div>&nbsp; &nbsp; &nbsp;&nbsp; return 0;</div><div>}</div><div>编译运行:</div><div>引用:</div><div>[root@localhost root]# ./packedtest &nbsp;</div><div>sizeof str = 5</div><div>sizeof str_struct = 5</div><div>sizeof str_temp = 6</div><div>sizeof str_nopacked = 6</div><div>GNU C的一大特色就是__attribute__机制。__attribute__可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。</div><div>__attribute__书写特征是：__attribute__前后都有两个下划线，并且后面会紧跟一对括弧，括弧里面是相应的__attribute__参数。</div><div>__attribute__语法格式为：</div><div>__attribute__ ((attribute-list))</div><div>其位置约束：放于声明的尾部“；”之前。</div><div>函数属性（Function Attribute）：函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。__attribute__机制也很容易同非GNU应用程序做到兼容之功效。</div><div>GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。</div><div>packed属性：使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。</div><div>网络通信通常分为基于数据结构的和基于流的。HTTP协议就是后者的一个例子。</div><div>&nbsp;&nbsp; 有时为了提高程序的处理速度和数据处理的方便，会使用基于数据结构的通信（不需要对流进行解析）。但是，当需要在多平台间进行通信时，基于数据结构的通信，往往要十分注意以下几个方面：</div><div>[1] 字节序</div><div>[2] 变量长度</div><div>[3] 内存对齐</div><div>&nbsp;&nbsp; 在常见的系统架构中（Linux X86，Windows），非单字节长度的变量类型，都是低字节在前，而在某些特定系统中，如Soalris Sparc平台，高字节在前。如果在发送数据前不进行处理，那么由Linux X86发向Soalris Sparc平台的数据值，势必会有极大的偏差，进而程序运行过程中无法出现预计的正常结果，更严重时，会导致段错误。</div><div>&nbsp;&nbsp; 对于此种情况，我们往往使用同一的字节序。在系统中，有ntohXXX(), htonXXX()等函数，负责将数据在网络字节序和本地字节序之间转换。虽然每种系统的本地字节序不同，但是对于所有系统来说，网络字节序是固定的 -----高字节在前。所以，可以以网络字节序为通信的标准，发送前，数据都转换为网络字节序。</div><div>&nbsp;&nbsp; 转换的过程，也建议使用ntohXXX(), htonXXX()等标准函数，这样代码可以轻松地在各平台间进行移植（像通信这种很少依赖系统API的代码，做成通用版本是不错的选择）。</div><div><br style="margin:0px;padding:0px;"/></div><div>&nbsp;&nbsp; 变量的长度，在不同的系统之间会有差别，如同是Linux2.6.18的平台，在64位系统中，指针的长度为8个字节，而在32位系统中，指针又是4个字 节的长度---此处只是举个例子，很少有人会将指针作为数据发送出去。下面是我整理的在64位Linux系统和32位Linux系统中，几种常见C语言变 量的长度：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; short &nbsp;&nbsp; int &nbsp;&nbsp; long &nbsp;&nbsp; long long &nbsp;&nbsp; ptr &nbsp;&nbsp; time_t</div><div>32位 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp;&nbsp; 4</div><div>64位 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp;&nbsp; 8</div><div>&nbsp;&nbsp; 在定义通信用的结构体时，应该考虑使用定常的数据类型，如uint32_t，4字节的固定长度，并且这属于标准C库(C99)，在各系统中都可使用。</div><div><br style="margin:0px;padding:0px;"/></div><div>&nbsp;&nbsp; 内存对齐的问题，也与系统是64位还是32位有关。如果你手头有32位和64位系统，不妨写个简单的程序测试一下，你就会看到同一个结构体，即便使用了定 常的数据类型，在不同系统中的大小是不同的。对齐往往是以4字节或8字节为准的，只要你写的测试程序，变量所占空间没有对齐到4或8的倍数即可，举个简单 的测试用的结构体的例子吧：</div><div>struct student</div><div>{</div><div>&nbsp;&nbsp; char name[7];</div><div>&nbsp;&nbsp; uint32_t id;</div><div>&nbsp;&nbsp; char subject[5];</div><div>};</div><div>&nbsp;&nbsp; 在每个系统上看下这个结构体的长度吧。</div><div>&nbsp;&nbsp; 内存对齐，往往是由编译器来做的，如果你使用的是gcc，可以在定义变量时，添加__attribute__，来决定是否使用内存对齐，或是内存对齐到几个字节，以上面的结构体为例：</div><div>1)到4字节，同样可指定对齐到8字节。</div><div>struct student</div><div>{</div><div>&nbsp;&nbsp; char name[7];</div><div>&nbsp;&nbsp; uint32_t id;</div><div>&nbsp;&nbsp; char subject[5];</div><div>} __attribute__ ((aligned(4)));</div><div><br style="margin:0px;padding:0px;"/></div><div>2)不对齐，结构体的长度，就是各个变量长度的和</div><div>struct student</div><div>{</div><div>&nbsp;&nbsp; char name[7];</div><div>&nbsp;&nbsp; uint32_t id;</div><div>&nbsp;&nbsp; char subject[5];</div><div>} __attribute__ ((packed));</div><div>One of the best (but little known) features of GNU C is the <span style="font-weight: bold;">__attribute__</span> mechanism, which allows a developer to attach characteristics to function declarations to allow the compiler to perform more error checking. It was designed in a way to be compatible with non-GNU implementations, and we&apos;ve been using this for <span style="font-style: italic;">years</span> in highly portable code with very good results.</div><div><center>Table of Contents</center><ol><li><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html#format" style="text-decoration: none;">__attribute__ format</a></div></li><li><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html#noreturn" style="text-decoration: none;">__attribute__ noreturn</a></div></li><li><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html#const" style="text-decoration: none;">__attribute__ const</a></div></li><li><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html#together" style="text-decoration: none;">Putting them together</a></div></li><li><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html#compat" style="text-decoration: none;">Compatibility with non-GNU compilers</a></div></li><li><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html#refs" style="text-decoration: none;">Other References</a></div></li></ol></div><div>Note that <span style="font-weight: bold;">__attribute__</span> spelled with two underscores before and two after, and there are always <span style="font-style: italic;">two</span> sets of parentheses surrounding the contents. There is a good reason for this - see below. Gnu CC needs to use the <span style="font-weight: bold;">-Wall</span> compiler directive to enable this (yes, there is a finer degree of warnings control available, but we are very big fans of max warnings anyway).</div><div><span style="font-weight: bold;">__ATTRIBUTE__ FORMAT</span></div><div>This <span style="font-weight: bold;">__attribute__</span> allows assigning <span style="font-weight: bold;">printf</span>-like or <span style="font-weight: bold;">scanf</span>-like characteristics to the declared function, and this enables the compiler to check the format string against the parameters provided throughout the code. This is <span style="font-style: italic;">exceptionally</span> helpful in tracking down hard-to-find bugs.</div><div>There are two flavors:</div><ul><li><div><span style="font-weight: bold;">__attribute__((format(printf,</span><span style="font-style: italic; font-weight: bold;">m</span><span style="font-weight: bold;">,</span><span style="font-style: italic; font-weight: bold;">n</span><span style="font-weight: bold;">)))</span></div></li><li><div><span style="font-weight: bold;">__attribute__((format(scanf,</span><span style="font-style: italic; font-weight: bold;">m</span><span style="font-weight: bold;">,</span><span style="font-style: italic; font-weight: bold;">n</span><span style="font-weight: bold;">)))</span></div></li></ul><div>but in practice we use the first one much more often.</div><div>The (<span style="font-style: italic;">m</span>) is the number of the &quot;format string&quot; parameter, and (<span style="font-style: italic;">n</span>) is the number of the first variadic parameter. To see some examples:</div><div>/* like printf() but to standard error only */</div><div><span style="font-weight: bold;">extern void eprintf(const char *format, ...)</span></div><div><span style="font-weight: bold;">&nbsp; &nbsp;__attribute__((format(printf, 1, 2)))</span>; /* <span style="font-style: italic;">1=format 2=params</span> */</div><div><br/></div><div>/* printf only if debugging is at the desired level */</div><div><span style="font-weight: bold;">extern void dprintf(int dlevel, const char *format, ...)</span></div><div><span style="font-weight: bold;">&nbsp; &nbsp;__attribute__((format(printf, 2, 3)))</span>; /* <span style="font-style: italic;">2=format 3=params</span> */</div><div>With the functions so declared, the compiler will examine the argument lists</div><div>$ <span style="font-weight: bold;">cat test.c</span></div><div><span style="font-style: italic;">1</span> extern void eprintf(const char *format, ...)</div><div><span style="font-style: italic;">2</span> <span style="font-weight: bold;">__attribute__((format(printf, 1, 2)))</span>;</div><div><span style="font-style: italic;">3</span></div><div><span style="font-style: italic;">4</span> void foo()</div><div><span style="font-style: italic;">5</span> {</div><div><span style="font-style: italic; font-weight: bold;">6</span> <span style="font-weight: bold;">eprintf(&quot;s=%s\n&quot;, 5);</span> /* <span style="font-style: italic;">error on this line</span> */</div><div><span style="font-style: italic;">7</span></div><div><span style="font-style: italic; font-weight: bold;">8</span> <span style="font-weight: bold;">eprintf(&quot;n=%d,%d,%d\n&quot;, 1, 2);</span> /* <span style="font-style: italic;">error on this line</span> */</div><div><span style="font-style: italic;">9</span> }</div><div><br/></div><div>$ <span style="font-weight: bold;">cc -Wall -c test.c</span></div><div>test.c: In function `foo&apos;:</div><div><span style="font-weight: bold;">test.c:6</span>: warning: format argument is not a pointer (arg 2)</div><div><span style="font-weight: bold;">test.c:8</span>: warning: too few arguments for format</div><div>Note that the &quot;standard&quot; library functions - printf and the like - are already understood by the compiler by default.</div><div><span style="font-weight: bold;">__ATTRIBUTE__ NORETURN</span></div><div>This attribute tells the compiler that the function won&apos;t ever return, and this can be used to suppress errors about code paths not being reached. The C library functions abort() and exit() are both declared with this attribute:</div><div>extern void exit(int) <span style="font-weight: bold;">__attribute__((noreturn))</span>;</div><div>extern void abort(void) <span style="font-weight: bold;">__attribute__((noreturn))</span>;</div><div>Once tagged this way, the compiler can keep track of paths through the code and suppress errors that won&apos;t ever happen due to the flow of control never returning after the function call.</div><div>In this example, two nearly-identical C source files refer to an &quot;exitnow()&quot; function that never returns, but without the <span style="font-weight: bold;">__attribute__</span>tag, the compiler issues a warning. The compiler is correct here, because it has no way of knowing that control doesn&apos;t return.</div><div>$ <span style="font-weight: bold;">cat test1.c</span></div><div>extern void exitnow();</div><div><br/></div><div>int foo(int n)</div><div>{</div><div>if ( n &gt; 0 )</div><div>&nbsp; &nbsp;{</div><div>exitnow();</div><div>&nbsp; &nbsp; &nbsp; &nbsp;/* <span style="font-style: italic;">control never reaches this point</span> */</div><div>&nbsp; &nbsp;}</div><div>else</div><div>return 0;</div><div>}</div><div><br/></div><div>$ <span style="font-weight: bold;">cc -c -Wall test1.c</span></div><div>test1.c: In function `foo&apos;:</div><div><span style="font-weight: bold;">test1.c:9: warning: this function may return with or without a value</span></div><div>But when we add <span style="font-weight: bold;">__attribute__</span>, the compiler suppresses the spurious warning:</div><div>$ <span style="font-weight: bold;">cat test2.c</span></div><div>extern void exitnow() <span style="font-weight: bold;">__attribute__((noreturn))</span>;</div><div><br/></div><div>int foo(int n)</div><div>{</div><div>if ( n &gt; 0 )</div><div>exitnow();</div><div>else</div><div>return 0;</div><div>}</div><div><br/></div><div>$ <span style="font-weight: bold;">cc -c -Wall test2.c</span></div><div><span style="font-style: italic;">no warnings!</span></div><div><span style="font-weight: bold;">__ATTRIBUTE__ CONST</span></div><div>This attribute marks the function as considering <span style="font-style: italic;">only</span> its numeric parameters. This is mainly intended for the compiler to optimize away repeated calls to a function that the compiler knows will return the same value repeatedly. It applies mostly to math functions that have no static state or side effects, and whose return is solely determined by the inputs.</div><div>In this highly-contrived example, the compiler normally <span style="font-style: italic;">must</span> call the <span style="font-weight: bold;">square()</span> function in every loop even though we know that it&apos;s going to return the same value each time:</div><div>extern int square(int n) <span style="font-weight: bold;">__attribute__((const))</span>;</div><div><br/></div><div>...</div><div>&nbsp; &nbsp;for (i = 0; i &lt; 100; i++ )</div><div>&nbsp; &nbsp;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp;total += square(5) + i;</div><div>&nbsp; &nbsp;}</div><div>By adding <span style="font-weight: bold;">__attribute__((const))</span>, the compiler can choose to call the function just once and cache the return value.</div><div>In virtually every case, <span style="font-weight: bold;">const</span> can&apos;t be used on functions that take pointers, because the function is not considering just the function parameters but <span style="font-style: italic;">also the data the parameters point to</span>, and it will almost certainly break the code very badly in ways that will be nearly impossible to track down.</div><div>Furthermore, the functions so tagged cannot have any side effects or static state, so things like <span style="font-weight: bold;">getchar()</span> or <span style="font-weight: bold;">time()</span> would behave very poorly under these circumstances.</div><div><span style="font-weight: bold;">PUTTING THEM TOGETHER</span></div><div>Multiple <span style="font-weight: bold;">__attributes__</span> can be strung together on a single declaration, and this is not uncommon in practice. You can either use two separate <span style="font-weight: bold;">__attribute__</span>s, or use one with a comma-separated list:</div><div>/* <span style="font-style: italic;">send printf-like message to stderr and exit</span> */</div><div>extern void die(const char *format, ...)</div><div>&nbsp; &nbsp;<span style="font-weight: bold;">__attribute__((noreturn))</span></div><div><span style="font-weight: bold;">&nbsp; &nbsp;__attribute__((format(printf, 1, 2)))</span>;</div><div><br/></div><div>/*or*/</div><div><br/></div><div>extern void die(const char *format, ...)</div><div>&nbsp; &nbsp;<span style="font-weight: bold;">__attribute__((noreturn, format(printf, 1, 2)))</span>;</div><div>If this is tucked away safely in a library header file, <span style="font-style: italic;">all</span> programs that call this function receive this checking.</div><div><span style="font-weight: bold;">COMPATIBILITY WITH NON-GNU COMPILERS</span></div><div>Fortunately, the <span style="font-weight: bold;">__attribute__</span> mechanism was cleverly designed in a way to make it easy to quietly eliminate them if used on platforms other than GNU C. Superficially, <span style="font-weight: bold;">__attribute__</span> appears to have multiple parameters (which would typically rule out using a macro), but the <span style="font-style: italic;">two</span> sets of parentheses effectively make it a single parameter, and in practice this works very nicely.</div><div>/* If we&apos;re not using GNU C, elide __attribute__ */</div><div>#ifndef __GNUC__</div><div># define __attribute__(x) /*NOTHING*/</div><div>#endif</div><div>Note that <span style="font-weight: bold;">__attribute__</span> applies to function <span style="font-style: italic;">declarations</span>, not <span style="font-style: italic;">definitions</span>, and we&apos;re not sure why this is. So when defining a function that merits this treatment, an extra declaration must be used (in the same file):</div><div>/* <span style="font-style: italic;">function declaration</span> */</div><div>void die(const char *format, ...) <span style="font-weight: bold;">__attribute__((noreturn))</span></div><div><span style="font-weight: bold;">__attribute__((format(printf,1,2)))</span>;</div><div><br/></div><div>void die(const char *format, ...)</div><div>{</div><div>&nbsp; &nbsp;/* <span style="font-style: italic;">function definition</span> */</div><div>}</div><div><span style="font-weight: bold;">OTHER REFERENCES</span></div><div>We&apos;ll note that there are many more attributes available, including those for <span style="font-weight: bold;">variables</span> and <span style="font-weight: bold;">types</span>, and they are not covered here: we have chosen to just touch on the high points. Those wishing more information can find it in the GNU online documentation at<a href="http://gcc.gnu.org/" style="text-decoration: none;">http://gcc.gnu.org</a>:</div><dl><dt>GCC 4.0</dt><dd style="margin:0px;padding:0px;"/><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html" style="text-decoration: none;">GCC 4.0 Function Attributes</a></dd><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html" style="text-decoration: none;">GCC 4.0 Variable Attributes</a></dd><dd><div><a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html" style="text-decoration: none;">GCC 4.0 Type Attributes</a></div></dd><dt>GCC 3.2</dt><dd style="margin:0px;padding:0px;"/><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html" style="text-decoration: none;">GCC 3.2 Function Attributes</a></dd><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html" style="text-decoration: none;">GCC 3.2 Variable Attributes</a></dd><dd><div><a href="http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Type-Attributes.html" style="text-decoration: none;">GCC 3.2 Type Attributes</a></div></dd><dt>GCC 3.1</dt><dd style="margin:0px;padding:0px;"/><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Function-Attributes.html" style="text-decoration: none;">GCC 3.1 Function Attributes</a></dd><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Variable-Attributes.html" style="text-decoration: none;">GCC 3.1 Variable Attributes</a></dd><dd><div><a href="http://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Type-Attributes.html" style="text-decoration: none;">GCC 3.1 Type Attributes</a></div></dd><dt>GCC 3.0.4</dt><dd style="margin:0px;padding:0px;"/><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-3.0.4/gcc_5.html#SEC94" style="text-decoration: none;">Function Attributes</a></dd><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-3.0.4/gcc_5.html#SEC101" style="text-decoration: none;">Variable Attributes</a></dd><dd><div><a href="http://gcc.gnu.org/onlinedocs/gcc-3.0.4/gcc_5.html#SEC102" style="text-decoration: none;">Type Attributes</a></div></dd><dt>GCC 2.95.3</dt><dd style="margin:0px;padding:0px;"/><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_4.html#SEC84" style="text-decoration: none;">Function Attributes</a></dd><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_4.html#SEC90" style="text-decoration: none;">Variable Attributes</a></dd><dd><div><a href="http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_4.html#SEC91" style="text-decoration: none;">Type Attributes</a></div></dd></dl><div><span style="font-weight: bold;">参考：</span></div><div><a href="http://blog.sina.com.cn/s/blog_644c3be70100i8ii.html" style="text-decoration: none;">http://blog.sina.com.cn/s/blog_644c3be70100i8ii.html</a></div><div><a href="http://hi.baidu.com/srbadxecnihqtue/item/039535e051a0d30f8d3ea8b1" style="text-decoration: none;">http://hi.baidu.com/srbadxecnihqtue/item/039535e051a0d30f8d3ea8b1</a></div><div><a href="http://www.cnblogs.com/respawn/archive/2012/07/09/2582078.html" style="text-decoration: none;">http://www.cnblogs.com/respawn/archive/2012/07/09/2582078.html</a></div><div><a href="http://qq164587043.blog.51cto.com/261469/187562" style="text-decoration: none;">http://qq164587043.blog.51cto.com/261469/187562</a></div><div><a href="http://my.oschina.net/u/174242/blog/72760" style="text-decoration: none;">http://my.oschina.net/u/174242/blog/72760</a></div><div><a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html" style="text-decoration: none;">http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html</a></div><div><a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes" style="text-decoration: none;">http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes</a></div><div><a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes" style="text-decoration: none;">http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes</a></div><div><a href="http://www.unixwiz.net/techtips/gnu-c-attributes.html" style="text-decoration: none;">http://www.unixwiz.net/techtips/gnu-c-attributes.html</a></div></div><div style="margin:0px;padding:0px;clear:both;"/><div><br/></div></div><div><div><br/></div><table bgcolor="#D4DDE5" border="0" width="100%"><colgroup><col/></colgroup><tbody><tr><td><h1>c++ 中__declspec 的用法 - ylclass - 博客园</h1><div><br/></div></td></tr></tbody></table><div><br/></div></div><div><br/></div><div><br/></div><div><h1>任意字节对齐的内存分配和释放</h1></div><div>2016年09月28日 23:00:54</div><div>阅读数：2041</div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;void *AllignedMalloc(size_t size, int aligned)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// aligned is a power of 2</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert((aligned&amp;(aligned - 1)) == 0);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 分配内存空间</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *data = malloc(sizeof(void *)+aligned + size);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 地址对齐</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **temp = (void **)data + 1;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **alignedData = (void **)(((size_t)temp + aligned - 1)&amp;-aligned);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 保存原始内存地址</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alignedData[-1] = data;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alignedData;&nbsp;&nbsp;// 被转换为一级指针</div><div>&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>void AlignedFree(void *data)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(((void **)data)[-1]);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;}</div></div><div><br style="outline:0px;box-sizing:border-box;word-break:break-all;"/></div><div><span style="font-weight: 400;">这里以32位系统，16字节对齐为例，用示意图表示更加清楚一点。</span></div><div><span style="font-weight: 400;">原始分配内存图</span></div><div style="box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 1.1em; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; overflow-x: auto; overflow-wrap: break-word; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;;"><en-media hash="384a3ef93432e80e236e1f6815b1b92d" type="image/png"/></span><br/></div><div>下面考虑两种情况:<br/></div><div><en-media hash="82966187bace4e25c7f48b53488e7b91" type="image/png"/></div><div><span style="font-weight: 400;">这里要注意转为二级指针后：</span></div><div><span style="font-weight: 400;">1. 指向的内存区域是指针变量，存放的是地址，即编译器对内存的解析发生变化</span></div><div><span style="font-weight: 400;">2. 对void **进行自增++，移动的是一个指针变量的大小</span></div><div><br/></div><div><en-media hash="141b38cdab51590db4384acefb7b95fd" type="image/png"/></div><div><br style="outline:0px;box-sizing:border-box;word-break:break-all;"/></div><div><span style="font-weight: 400;">在mmx，sse优化的时候经常要求内存按8，16字节对齐。但是默认的编译器一般都是8字节对齐。所以需要在分配内存的时候，能按16或则其他字节对齐。</span></div><div><span style="font-weight: 400;">以下是从xvid工程中找到的任意字节对齐的内存分配函数。</span></div><div><br style="outline:0px;box-sizing:border-box;word-break:break-all;"/></div><p style="outline:0px;padding:0px;box-sizing:border-box;margin:0px 0px 16px;font-size:16px;color:rgb(79, 79, 79);font-weight:400;line-height:26px;text-align:justify;word-break:break-all;"/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/*****************************************************************************</div><div>* align_malloc</div><div>*</div><div>* This function allocates &apos;size&apos; bytes (usable by the user) on the heap and</div><div>* takes care of the requested &apos;alignment&apos;.</div><div>* In order to align the allocated memory block, the xvid_malloc allocates</div><div>* &apos;size&apos; bytes + &apos;alignment&apos; bytes. So try to keep alignment very small</div><div>* when allocating small pieces of memory.</div><div>*</div><div>* NB : a block allocated by xvid_malloc _must_ be freed with xvid_free</div><div>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the libc free will return an error)</div><div>*</div><div>* Returned value : - NULL on error</div><div>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Pointer to the allocated aligned block</div><div>*</div><div>****************************************************************************/</div><div>void * align_malloc(unsigned int size, unsigned int alignment)</div><div>{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;unsigned char * mem_ptr;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;unsigned char * tmp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;if(!alignment) alignment=4; //至少按4对齐</div><div>&nbsp;&nbsp;&nbsp;&nbsp;/* Allocate the required size memory + alignment so we</div><div>&nbsp;&nbsp;&nbsp;&nbsp;* can realign the data if necessary */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;if ((tmp = (unsigned char *) malloc(size + alignment)) != NULL) {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Align the tmp pointer */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_ptr =</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unsigned char *) ((unsigned int) (tmp + alignment - 1) &amp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(~(unsigned int) (alignment - 1)));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Special case where malloc have already satisfied the alignment</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* We must add alignment to mem_ptr because we must store</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* (mem_ptr - tmp) in *(mem_ptr-1)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* If we do not add alignment to mem_ptr then *(mem_ptr-1) points</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* to a forbidden memory space */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mem_ptr == tmp)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_ptr += alignment;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* (mem_ptr - tmp) is stored in *(mem_ptr-1) so we are able to retrieve</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* the real malloc block allocated and free it in xvid_free */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(mem_ptr - 1) = (unsigned char) (mem_ptr - tmp);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//PRT(&quot;Alloc mem addr: 0x%08x, size:% 8d, file:%s &lt;line:%d&gt;, &quot;, tmp, size, file, line);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Return the aligned pointer */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ((void *)mem_ptr);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;return(NULL);</div><div>}</div><div>/*****************************************************************************</div><div>* align_free</div><div>*</div><div>* Free a previously &apos;xvid_malloc&apos; allocated block. Does not free NULL</div><div>* references.</div><div>*</div><div>* Returned value : None.</div><div>*</div><div>****************************************************************************/</div><div>void align_free(void *mem_ptr)</div><div>{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;unsigned char *ptr;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;if (mem_ptr == NULL)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;/* Aligned pointer */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;ptr = (&nbsp;&nbsp;&nbsp;&nbsp;unsigned char *)mem_ptr;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;/* *(ptr - 1) holds the offset to the real allocated block</div><div>&nbsp;&nbsp;&nbsp;&nbsp;* we sub that offset os we free the real pointer */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;ptr -= *(ptr - 1);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;/* Free the memory */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;free(ptr);</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div><br style="outline:0px;box-sizing:border-box;word-break:break-all;"/></div><p style="outline:0px;padding:0px;box-sizing:border-box;margin:0px 0px 16px;font-size:16px;color:rgb(79, 79, 79);font-weight:400;line-height:26px;text-align:justify;word-break:break-all;"/><div style="white-space:pre-wrap;color:rgb(0, 0, 0);outline:0px;padding:8px;margin:0px 0px 24px;position:relative;box-sizing:border-box;word-wrap:break-word;overflow-x:auto;font-family:Consolas, Inconsolata, Courier, monospace;font-size:14px;line-height:22px;word-break:break-all;"/><p style="outline:0px;padding:0px;box-sizing:border-box;margin:0px 0px 16px;font-size:16px;color:rgb(79, 79, 79);font-weight:400;line-height:26px;text-align:justify;word-break:break-all;"/><p style="outline:0px;padding:0px;box-sizing:border-box;margin:0px 0px 16px;font-size:16px;color:rgb(79, 79, 79);font-weight:400;line-height:26px;text-align:justify;word-break:break-all;"/><div><span style="font-weight: 400;">这个以任意字节内存对齐在笔试中已经遇到两次，然而却还是不会。再找工作中这个题目很能体现一个人的基础水平，注意学习。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define ngx_align(d, a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((d) + (a - 1)) &amp; ~(a - 1))</div><div>#include &lt;stdio.h&gt;</div><div>int i;</div><div>int main() {</div><div>&nbsp;&nbsp;&nbsp;printf(&quot;64\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=256;i++) {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%3d %3d,&quot;,i,ngx_align(i, 64));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (7==i%8) printf(&quot;\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;printf(&quot;\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;printf(&quot;128\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=256;i++) {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%3d %3d,&quot;,i,ngx_align(i, 128));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (7==i%8) printf(&quot;\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;printf(&quot;\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;return 0;</div><div>}</div><div>//64</div><div>//&nbsp;&nbsp;1&nbsp;&nbsp;64,&nbsp;&nbsp;2&nbsp;&nbsp;64,&nbsp;&nbsp;3&nbsp;&nbsp;64,&nbsp;&nbsp;4&nbsp;&nbsp;64,&nbsp;&nbsp;5&nbsp;&nbsp;64,&nbsp;&nbsp;6&nbsp;&nbsp;64,&nbsp;&nbsp;7&nbsp;&nbsp;64,</div><div>//&nbsp;&nbsp;8&nbsp;&nbsp;64,&nbsp;&nbsp;9&nbsp;&nbsp;64, 10&nbsp;&nbsp;64, 11&nbsp;&nbsp;64, 12&nbsp;&nbsp;64, 13&nbsp;&nbsp;64, 14&nbsp;&nbsp;64, 15&nbsp;&nbsp;64,</div><div>// 16&nbsp;&nbsp;64, 17&nbsp;&nbsp;64, 18&nbsp;&nbsp;64, 19&nbsp;&nbsp;64, 20&nbsp;&nbsp;64, 21&nbsp;&nbsp;64, 22&nbsp;&nbsp;64, 23&nbsp;&nbsp;64,</div><div>// 24&nbsp;&nbsp;64, 25&nbsp;&nbsp;64, 26&nbsp;&nbsp;64, 27&nbsp;&nbsp;64, 28&nbsp;&nbsp;64, 29&nbsp;&nbsp;64, 30&nbsp;&nbsp;64, 31&nbsp;&nbsp;64,</div><div>// 32&nbsp;&nbsp;64, 33&nbsp;&nbsp;64, 34&nbsp;&nbsp;64, 35&nbsp;&nbsp;64, 36&nbsp;&nbsp;64, 37&nbsp;&nbsp;64, 38&nbsp;&nbsp;64, 39&nbsp;&nbsp;64,</div><div>// 40&nbsp;&nbsp;64, 41&nbsp;&nbsp;64, 42&nbsp;&nbsp;64, 43&nbsp;&nbsp;64, 44&nbsp;&nbsp;64, 45&nbsp;&nbsp;64, 46&nbsp;&nbsp;64, 47&nbsp;&nbsp;64,</div><div>// 48&nbsp;&nbsp;64, 49&nbsp;&nbsp;64, 50&nbsp;&nbsp;64, 51&nbsp;&nbsp;64, 52&nbsp;&nbsp;64, 53&nbsp;&nbsp;64, 54&nbsp;&nbsp;64, 55&nbsp;&nbsp;64,</div><div>// 56&nbsp;&nbsp;64, 57&nbsp;&nbsp;64, 58&nbsp;&nbsp;64, 59&nbsp;&nbsp;64, 60&nbsp;&nbsp;64, 61&nbsp;&nbsp;64, 62&nbsp;&nbsp;64, 63&nbsp;&nbsp;64,</div><div>// 64&nbsp;&nbsp;64, 65 128, 66 128, 67 128, 68 128, 69 128, 70 128, 71 128,</div><div>// 72 128, 73 128, 74 128, 75 128, 76 128, 77 128, 78 128, 79 128,</div><div>// 80 128, 81 128, 82 128, 83 128, 84 128, 85 128, 86 128, 87 128,</div><div>// 88 128, 89 128, 90 128, 91 128, 92 128, 93 128, 94 128, 95 128,</div><div>// 96 128, 97 128, 98 128, 99 128,100 128,101 128,102 128,103 128,</div><div>//104 128,105 128,106 128,107 128,108 128,109 128,110 128,111 128,</div><div>//112 128,113 128,114 128,115 128,116 128,117 128,118 128,119 128,</div><div>//120 128,121 128,122 128,123 128,124 128,125 128,126 128,127 128,</div><div>//128 128,129 192,130 192,131 192,132 192,133 192,134 192,135 192,</div><div>//136 192,137 192,138 192,139 192,140 192,141 192,142 192,143 192,</div><div>//144 192,145 192,146 192,147 192,148 192,149 192,150 192,151 192,</div><div>//152 192,153 192,154 192,155 192,156 192,157 192,158 192,159 192,</div><div>//160 192,161 192,162 192,163 192,164 192,165 192,166 192,167 192,</div><div>//168 192,169 192,170 192,171 192,172 192,173 192,174 192,175 192,</div><div>//176 192,177 192,178 192,179 192,180 192,181 192,182 192,183 192,</div><div>//184 192,185 192,186 192,187 192,188 192,189 192,190 192,191 192,</div><div>//192 192,193 256,194 256,195 256,196 256,197 256,198 256,199 256,</div><div>//200 256,201 256,202 256,203 256,204 256,205 256,206 256,207 256,</div><div>//208 256,209 256,210 256,211 256,212 256,213 256,214 256,215 256,</div><div>//216 256,217 256,218 256,219 256,220 256,221 256,222 256,223 256,</div><div>//224 256,225 256,226 256,227 256,228 256,229 256,230 256,231 256,</div><div>//232 256,233 256,234 256,235 256,236 256,237 256,238 256,239 256,</div><div>//240 256,241 256,242 256,243 256,244 256,245 256,246 256,247 256,</div><div>//248 256,249 256,250 256,251 256,252 256,253 256,254 256,255 256,</div><div>//256 256,</div><div>//128</div><div>//&nbsp;&nbsp;1 128,&nbsp;&nbsp;2 128,&nbsp;&nbsp;3 128,&nbsp;&nbsp;4 128,&nbsp;&nbsp;5 128,&nbsp;&nbsp;6 128,&nbsp;&nbsp;7 128,</div><div>//&nbsp;&nbsp;8 128,&nbsp;&nbsp;9 128, 10 128, 11 128, 12 128, 13 128, 14 128, 15 128,</div><div>// 16 128, 17 128, 18 128, 19 128, 20 128, 21 128, 22 128, 23 128,</div><div>// 24 128, 25 128, 26 128, 27 128, 28 128, 29 128, 30 128, 31 128,</div><div>// 32 128, 33 128, 34 128, 35 128, 36 128, 37 128, 38 128, 39 128,</div><div>// 40 128, 41 128, 42 128, 43 128, 44 128, 45 128, 46 128, 47 128,</div><div>// 48 128, 49 128, 50 128, 51 128, 52 128, 53 128, 54 128, 55 128,</div><div>// 56 128, 57 128, 58 128, 59 128, 60 128, 61 128, 62 128, 63 128,</div><div>// 64 128, 65 128, 66 128, 67 128, 68 128, 69 128, 70 128, 71 128,</div><div>// 72 128, 73 128, 74 128, 75 128, 76 128, 77 128, 78 128, 79 128,</div><div>// 80 128, 81 128, 82 128, 83 128, 84 128, 85 128, 86 128, 87 128,</div><div>// 88 128, 89 128, 90 128, 91 128, 92 128, 93 128, 94 128, 95 128,</div><div>// 96 128, 97 128, 98 128, 99 128,100 128,101 128,102 128,103 128,</div><div>//104 128,105 128,106 128,107 128,108 128,109 128,110 128,111 128,</div><div>//112 128,113 128,114 128,115 128,116 128,117 128,118 128,119 128,</div><div>//120 128,121 128,122 128,123 128,124 128,125 128,126 128,127 128,</div><div>//128 128,129 256,130 256,131 256,132 256,133 256,134 256,135 256,</div><div>//136 256,137 256,138 256,139 256,140 256,141 256,142 256,143 256,</div><div>//144 256,145 256,146 256,147 256,148 256,149 256,150 256,151 256,</div><div>//152 256,153 256,154 256,155 256,156 256,157 256,158 256,159 256,</div><div>//160 256,161 256,162 256,163 256,164 256,165 256,166 256,167 256,</div><div>//168 256,169 256,170 256,171 256,172 256,173 256,174 256,175 256,</div><div>//176 256,177 256,178 256,179 256,180 256,181 256,182 256,183 256,</div><div>//184 256,185 256,186 256,187 256,188 256,189 256,190 256,191 256,</div><div>//192 256,193 256,194 256,195 256,196 256,197 256,198 256,199 256,</div><div>//200 256,201 256,202 256,203 256,204 256,205 256,206 256,207 256,</div><div>//208 256,209 256,210 256,211 256,212 256,213 256,214 256,215 256,</div><div>//216 256,217 256,218 256,219 256,220 256,221 256,222 256,223 256,</div><div>//224 256,225 256,226 256,227 256,228 256,229 256,230 256,231 256,</div><div>//232 256,233 256,234 256,235 256,236 256,237 256,238 256,239 256,</div><div>//240 256,241 256,242 256,243 256,244 256,245 256,246 256,247 256,</div><div>//248 256,249 256,250 256,251 256,252 256,253 256,254 256,255 256,</div><div>//256 256,</div><div>//</div><div><br/></div><div><br/></div></div><div>类似于取模，只不过它取的是能被整除的部分而不是模。</div><div>#define ngx_align(d, a) (((d) + (a - 1)) &amp; ~(a - 1))</div><div>1）先看~（a-1）的含义</div><div>假设a是8 对应二进制是0000 1000</div><div>（a-1）对应的就是 0000 0111</div><div>~（a-1）对应的是 1111 1000</div><div>任何一个数 与~（a-1）按位相与 就是把第三方置0 也就是把该数变成 8的倍数</div><div>对应题目中的就是 64、128的倍数 也就形成了对齐</div><div>2）对于d + （a-1）的操作目的就是</div><div>eg：70以64对齐 结果是128而不是64的区别了</div><div>左半部分 d+a-1 保证处理后的值，这个值除以a得到的商（如果d%a=0,商不变，否则商+1）</div><div>右半部分&amp;~(a-1)相当于把余数抹去。</div><div>这里，对a有要求，a必须是2的k次幂，也就是a=1,2,4,8,16....</div><div>内存的对其问题，目的是为了加快IO效率。</div><p style="outline:0px;padding:0px;box-sizing:border-box;margin:0px 0px 16px;font-size:16px;color:rgb(79, 79, 79);font-weight:400;line-height:26px;text-align:justify;word-break:break-all;"/></div><div style="clear: both;"/><div><br/></div><div><br/></div><div><br/></div><div><div><span style="font-weight: 700;">结构体边界对齐</span></div><div>&nbsp; &nbsp;许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常它为4或8)的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。当一种类型S的对齐模数与另一种类型T的对齐模数的比值是大于1的整数，我们就称类型S的对齐要求比T强(严格)，而称T比S弱(宽松)。这种强制的要求<span style="font-weight: 700;">一来简化了处理器与内存之间传输系统的设计，二来可以提升读取数据的速度</span><span style="font-weight: 700;">。</span>比如这么一种处理器，它每次读写内存的时候都从某个8倍数的地址开始，一次读出或写入8个字节的数据，假如软件能保证double类型的数据都从8倍数地址开始，那么读或写一个double类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的8字节内存块上。某些处理器在数据不满足对齐要求的情况下可能会出错，但是Intel的IA32架构的处理器则不管数据是否对齐都能正确工作。不过Intel奉劝大家，如果想提升性能，那么所有的程序数据都应该尽可能地对齐。</div><p style="margin:0px 0px 0.75em;font-size:16px;line-height:1.7em;text-indent:1em;"/><div>规则:</div><div>　<span style="font-weight: 700;">　第一,编译器按照成员列表的顺序给每个成员分配内存.</span></div><div><span style="font-weight: 700;">　　第二,当成员需要满足正确的边界对齐时,成员之间用额外字节填充.</span></div><div><span style="font-weight: 700;">　　第三,结构体的首地址必须满足结构体中边界要求最为严格的数据类型所要求的地址.</span></div><div><span style="font-weight: 700;">　　第四,结构体的大小为其最宽基本类型的整数倍.</span></div><div>　　sizeof操作符能够得出一个结构体的整体长度,包括因边界对齐而额外填充的那些字节.</div><div>　　offsetof(type, member)宏能求得成员在结构体内的偏移,返回size_t.</div><p style="margin:5px auto;font-size:13px;line-height:1.5;text-indent:1em;font-family:Arial;"/><div>关于struct的边界对齐问题</div><div>Intel、微软等公司曾经出过一道类似的面试题：</div><div>1. #include &lt;iostream.h&gt;</div><div>2. #pragma pack(8)</div><div>3. struct example1</div><div>4. {</div><div>5. short a;</div><div>6. long b;</div><div>7. };</div><div>8. struct example2</div><div>9. {</div><div>10. char c;</div><div>11. example1 struct1;</div><div>12. short e; &nbsp; &nbsp;</div><div>13. };</div><div>14. #pragma pack()</div><div>15. int main(int argc, char* argv[])</div><div>16. {</div><div>17. example2 struct2;</div><div>18. cout &lt;&lt; sizeof(example1) &lt;&lt; endl;</div><div>19. cout &lt;&lt; sizeof(example2) &lt;&lt; endl;</div><div>20. cout &lt;&lt; (unsigned int)(&amp;struct2.struct1) - (unsigned int)(&amp;struct2) &lt;&lt; endl;</div><div>21. return 0;</div><div>22. }</div><div>问程序的输入结果是什么？</div><div>答案是：</div><div>8</div><div>16</div><div>4</div><div>　　不明白？还是不明白？下面一一道来：</div><div>2.1 自然对界</div><div>　　struct是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如 array、struct、union等）的数据单元。对于结构体，编译器会自动进行成员变量的对齐，以提高运算效率。缺省情况下，编译器为结构体的每个 成员按其自然对界（natural alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</div><div>　　自然对界(natural alignment)即默认对齐方式，是指按结构体的成员中size最大的成员对齐。</div><div>　　例如：</div><div>struct naturalalign</div><div>{</div><div>char a;</div><div>short b;</div><div>char c;</div><div>};</div><div>　　在上述结构体中，size最大的是short，其长度为2字节，因而结构体中的char成员a、c都以2为单位对齐，sizeof(naturalalign)的结果等于6；</div><div>　　如果改为：</div><div>struct naturalalign</div><div>{</div><div>char a;</div><div>int b;</div><div>char c;</div><div>};</div><div>　　其结果显然为12。</div><div>2.2指定对界</div><div>　　一般地，可以通过下面的方法来改变缺省的对界条件：</div><div>　　· 使用伪指令#pragma pack (n)，编译器将按照n个字节对齐；</div><div>　　· 使用伪指令#pragma pack ()，取消自定义字节对齐方式。</div><div>　　注意：如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界。</div><div>　　例如：</div><div>#pragma pack (n)</div><div>struct naturalalign</div><div>{</div><div>char a;</div><div>int b;</div><div>char c;</div><div>};</div><div>#pragma pack ()</div><div>　　当n为4、8、16时，其对齐方式均一样，sizeof(naturalalign)的结果都等于12。而当n为2时，其发挥了作用，使得sizeof(naturalalign)的结果为8。</div><div>　　在VC++ 6.0编译器中，我们可以指定其对界方式，其操作方式为依次选择projetct &gt; setting &gt; C/C++菜单，在struct member alignment中指定你要的对界方式。</div><div>　　另外，通过__attribute((aligned (n)))也可以让所作用的结构体成员对齐在n字节边界上，但是它较少被使用，因而不作详细讲解。</div><div>2.3 面试题的解答</div><div>　　至此，我们可以对Intel、微软的面试题进行全面的解答。</div><div>　　程序中第2行#pragma pack (8)虽然指定了对界为8，但是由于struct example1中的成员最大size为4（long变量size为4），故struct example1仍然按4字节对界，struct example1的size为8，即第18行的输出结果；</div><div>　　struct example2中包含了struct example1，其本身包含的简单数据成员的最大size为2（short变量e），但是因为其包含了struct example1，而struct example1中的最大成员size为4，struct example2也应以4对界，因为8大于4,所以#pragma pack (8)中指定的对界对struct example2也不起作用，故19行的输出结果为16；</div><div>　　由于struct example2中的成员以4为单位对界，故其char变量c后应补充3个空，其后才是成员struct1的内存空间，20行的输出结果为4。</div><div>&nbsp;</div><div>补充：上面说的还不是很清楚，总结一下：在默认情况下，VC规定各个成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该类型所占字节数的 倍数。 同时为了确保结构的大小为字节边界数（结构中占用最大空间 的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。(supermonkey注: 其实这里相当于把example1的成员展开到example2中来判断!)</div><div>ARM内存边界对齐以及sizeof问题</div><div><br/></div><p style="margin:0px 0px 0.75em;font-size:14px;line-height:26px;text-indent:1em;font-family:Arial;"/><div>默认情况下，在32位cpu里，gcc对于结构体的对齐方式是按照四个字节来对齐的。看以下结构体</div><div>　　typedef struct pack{</div><div>　　char a;</div><div>　　int b;</div><div>　　short c;</div><div>　　}pack;</div><div>　　对于Pack结构体，默认情况下在arm/386平台下(别的平台没试过)sizeof(pack)=12,求解过程如下:</div><div>　　sizeof(char)=1;</div><div>　　下一个int b,由于是四个字节,要求b的开始地址从32的整数倍开始,故需要在a后面填充3个没用的字节,记为dump(3),sizeof(b)=4,此时相当于结构体扩充为</div><div>　　char a;</div><div>　　char dump(3);</div><div>　　int b;</div><div>　　看short c,现在c的前面有8个字节,c是两个字节,c的开始地址是从16的整数开始,在b前面不需再加东西.此时对于结构体来说,sizeof(pack)=10,但是这不是最终结果,最后总的字节数也要能被4个字节整除,所以还需在short c后面再加</div><div>　　dump(2);</div><div>　　故总的字节数为12.</div><div>　　当然以上说的只是简单的情况,下面谈谈arm,x86在gcc里关于内存边界字节对齐的区别.对于同样的结构体,在386下</div><div>　　#prama pack(1)</div><div>　　后,sizeof(pack)=1 4 2=7</div><div>　　而在arm下同样的操作sizeof(pack)=1 4 2 1=8,即虽然b根a之间不要填充但总的长度必须要是4的整数倍.</div><div>　　在arm 下要使结构体按指定字节对齐,可行的方法</div><div>　　1.在makefile里加-fpack-struct 选项,这样的话对所有的结构按一字节对齐.</div><div>　　不得不说,确实有那么些质量较差的程序可能需要你部分自然对齐,部分一字 节对齐,此时</div><div>　　2. typedef struct pack{</div><div>　　}__attribute__((packed))</div><div>　　可利用__attribute__属性</div><div>　　当然最后的方式,还是自己去看arm体系结构与gcc编译选项了。</div></div><div style="margin-top:20px;font-size:16px;line-height:1.7em;"/><div><br/></div><div><br/></div>