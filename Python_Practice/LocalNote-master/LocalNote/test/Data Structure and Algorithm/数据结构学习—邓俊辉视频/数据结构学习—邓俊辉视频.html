<div><div align="left" style="min-height: 18pt;"><span style="font-weight: bold;"><font face="宋体" style="font-size: 18pt;">算法与算法分析</font></span></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">计算：</font></div><div align="left" style="min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">计算(绳索计算机,尺规计算机，排序算法)&nbsp; 计算模型</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法的定义：即特定计算模型下，旨在解决特定问题的指令序列</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法的重要特性：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">输入&nbsp;&nbsp;&nbsp;&nbsp; 待处理的信息（问题）</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">输出&nbsp;&nbsp;&nbsp;&nbsp; 经处理的信息（答案）</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">正确性 的确可以解决指定的问题</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">确定性 任一算法都可以描述为一个由基本操作组成的序列</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">可行性 每一基本操作都可实现，且在常数时间内完成</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">有穷性 对于任何输入，经有穷次基本操作，都可以得到输出(</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">Hailstone问题的分析)</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法设计的要求：正确，健壮，可读，<span style="color: rgb(255, 0, 0);">效率</span></font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法分析：对算法的进行度量</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法分析的两个要求：正确性，成本(<span style="color: rgb(255, 0, 0);">运行时间</span>+存储空间)</font></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法分析的工具：</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">计算模型：直尺</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">运行时间的影响因素与衡量：</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">1.问题规模</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; T(N):用算法 A 求解某一问题规模为 n 的实例，所需的计算成本</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">2.最坏情况：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">T(n) = max(T(P) | |P| = n}</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">3.理想模型：不同情况下，算法成本不同，使使用模型独立于具体平台；图灵机，RAM模型(无线空间)</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把计算成本问题转化为算法需要执行的基本操作次数</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法的执行过程可以记录为一张表，表的行数既是所执行基本指令的总条数，他可以客观的度量算法的执行时间</font></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">大o记号：刻度</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">这里更关心足够大的问题，注重考察成本的增长趋势</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">渐进分析：在问题规模足够大后，计算成本如何增长？</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 21pt;"><font face="宋体" style="font-size: 12pt;">T(n) = O(f(n)) iff ∃ c &gt; 0，当n ≫ 2后，T(n) &lt; c × f(n)</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">性质： 常系数可忽略：O(f(n)) = O(c × f(n))</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">低次项可忽略：O(na + nb) = O(na), a &gt; b &gt; 0</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 23pt;"><font face="宋体" style="font-size: 12pt;">T(n) = Ω(f(n))： ∃ c &gt; 0，当n ≫ 2后，T(n) &gt; c × f(n)</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 23pt;"><font face="宋体" style="font-size: 12pt;">T(n) = Θ(f(n))： ∃ c1&gt;c2&gt;0，当n ≫ 2后，c1×f(n) &gt; T(n) &gt; c2×f(n)</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">高效解：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">常数复杂度：O(1) 一定不含循环,一定不含分支转向,一定不能有（递归）调用,全是顺序执行即可</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">对数复杂度:O(log n) 常底数无所谓，常数次幂无所谓，对数多项式无所谓，复杂度无限接近常数</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">有效解：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">多项式复杂度,:O(n <span style="vertical-align: super;">c</span>),线性复杂度，O(n <span style="vertical-align: super;">1</span>)</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">难解</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">指数复杂度：O(2 <span style="vertical-align: super;">n</span>)</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">2‐Subset实例：只存在指数复杂度算法，无法存在多项式复杂度算法</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">增长速度</font></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法分析的思路与方法：</font></div><div align="left" style="min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">主要任务：正确性（不变性*单调性)+复杂度</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">复杂度分析的主要方法：</font></div><div align="left" style="min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">迭代：级数求和&nbsp;&nbsp; 递归：递归跟踪 + 递推方程&nbsp;&nbsp;&nbsp;&nbsp; 猜测与验证</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">级数：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法级数： 与末项平方同项</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">幂方级数：比幂次高一阶</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">几何级数：与末项同阶</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">收敛级数：为常数复杂度</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">调和级数：为对数复杂度</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">对数级数: 为对数复杂度</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">循环： 使用图形观察，如何使用级数评估循环的复杂度</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">起泡排序算法的介绍与正确性的判断：通过发现算法的不变性与单调性来判断正确性</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">定量估算：封底估算</font></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">迭代与递归：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">算法的思路:(分治策略)</font></div><div align="left" style="margin-left:19mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">减而治之：把一个大规模问题分为两个子问题（一个为平凡问题，一个是缩减）线性递归</font></div><div align="left" style="margin-left:29mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">数组倒置：递归：问题规模的奇er性</font></div><div align="left" style="margin-left:19mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">分而而治之：二分递归</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">算法的效率分析：</font></div><div align="left" style="margin-left:19mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">递归跟踪分析：检查每一个递归实例累计的时间（简单算法）</font></div><div align="left" style="margin-left:19mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">递推方程：递推方程+递归基</font></div><div align="left" style="margin: 0mm 0mm 0mm 40px; text-indent: 0mm; min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">递归消除：</font></div><div align="left" style="margin: 0mm 0mm 0mm 80px; text-indent: 0mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">数组求和&amp;找最大的两个元素:</font></div></div><div align="left" style="margin: 0mm 0mm 0mm 80px; text-indent: 0mm; min-height: 18pt;"><font face="宋体" style="font-size: 12pt;"><span style="text-indent: 0mm; min-height: 18pt;">迭代：</span><span style="text-indent: 0mm; min-height: 18pt;">&nbsp;</span> <span style="text-indent: 0mm; min-height: 18pt;">不断累加</span><span style="text-indent: 0mm; min-height: 18pt;">&nbsp;&nbsp;&nbsp;&nbsp;</span> <span style="text-indent: 0mm; min-height: 18pt;">空间(不考虑输入)</span></font></div><div align="left" style="margin: 0mm 0mm 0mm 80px; text-indent: 0mm; min-height: 18pt;"><div><span style="text-indent: 0mm; min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">递归：</font></span></div></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">动态规划：</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">通过递归找出问题的正确解，然后通过动态规划为迭代从而改善其的效率</font></div><div align="left" style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">Fib()分析：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">递归方法(使用递推方程，递归跟踪分析算法的效率，使用封底估算进行定量估算)</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">迭代：</font></div><div align="left" style="margin-left:19mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">记忆方法，动态规划</font></div><div align="left" style="min-height: 16pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;</font></div><div align="left" style="min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">最长公共子序列(LCS)：</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">子序列的定义，最长公共子序列存在有多种，有歧义的情况</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">通过递归寻找正确解(减而治之与分而而治之)，</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">正确性的分析</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 19pt;"><font face="宋体" style="font-size: 12pt;">复杂度分析(发现又是指数复杂度)</font></div><div align="left" style="margin-left:10mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">把递归修改为迭代</font></div><div align="left" style="margin-right: 0mm; text-indent: 0mm; margin-top: 0mm; margin-bottom: 0mm; min-height: 18pt;"><font face="宋体" style="font-size: 12pt;"><span style="min-height: 22pt;">线性序列</span> <span style="min-height: 22pt;">(</span> <span style="min-height: 22pt;">最简单的两种线性结构</span> <span style="min-height: 22pt;">):</span> <span style="min-height: 22pt;">向量与列表</span></font></div><div style="min-height: 22pt;"><font face="宋体" style="font-size: 12pt;"><span style="min-height: 22pt;">抽象数据类型</span> <span style="min-height: 22pt;">(</span> <span style="min-height: 22pt;">数据模型+相应操作</span> <span style="min-height: 22pt;">)</span> <span style="min-height: 22pt;">，数据结构</span> <span style="min-height: 22pt;">(</span> <span style="min-height: 22pt;">基于某种特定语言，实现ADTD 一套算法</span> <span style="min-height: 22pt;">)</span></font></div><div style="min-height: 21pt;"><span style="min-height: 21pt;"><font face="宋体" style="font-size: 18pt;"><b>向量：</b></font></span></div><div style="min-height: 21pt;"><div><font face="宋体" style="font-size: 12pt;"><span style="font-weight: bold;">定义：</span> 是数组的抽象与泛化，由一组元素安装线性次序封转而成，“循秩访问” （ call-by-rank）。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="min-height: 21pt;"><div><span style="font-weight: bold;"><font face="宋体" style="font-size: 12pt;">接口与实现：</font></span></div><div><font face="宋体" style="font-size: 12pt;">接口：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<en-media hash="245491fd44df5f9094b6a36dbc1619b2" style="height: auto;" type="image/png" width="869"/></font></div><div><font face="宋体" style="font-size: 12pt;">向量的通用方法—vector模板类：</font></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div></div><div style="min-height: 21pt;"><div><span style="font-weight: bold;"><font face="宋体" style="font-size: 12pt;">容量管理：</font></span></div><div><font face="宋体" style="font-size: 12pt;">静态空间管理：容量固定，会产生上溢与下溢</font></div><div><font face="宋体" style="font-size: 12pt;">动态空间管理：扩容算法的实现与原理，其物理地址会有改变，但是不会出现野指针。</font></div><blockquote><div><font face="宋体" style="font-size: 12pt;">扩容：</font></div></blockquote><blockquote><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递增式扩容：追加固定大小的容量(最坏情况下分析，累计扩容时间为O（n <span style="vertical-align: super;">2</span> ），分摊每一次扩容需要O（n）时间)</font></div></blockquote><blockquote><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加倍式扩容：每一次扩容为之前容量的两倍(最坏情况下分析，累计扩容时间为O（n），分摊每一次扩容需要O（1）时间)</font></div></blockquote><blockquote><div><font face="宋体" style="font-size: 12pt;">平均复杂度与分摊复杂度</font></div></blockquote><blockquote><div><font face="宋体" style="font-size: 12pt;">缩容：</font></div></blockquote><blockquote><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></blockquote></div><div style="min-height: 21pt;"><div><font face="宋体" style="font-size: 12pt;"><span style="font-weight: bold;">常规向量的基本操作</span>：&nbsp;&nbsp;</font></div><div align="left" style="min-height: 21pt;"><div><font face="宋体" style="font-size: 12pt;">构造与析构：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;构造：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认构造方法:首先根据创建者指定的初始容量， 向系统申请空间，以创建内部私</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">有数组_elem[].</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于复制的构造方法:是以某个已有的向量或数组为蓝本，进行（局部或整体的） 克隆复制的实现：复制为长度的两倍）;&nbsp; &nbsp; &nbsp;</font></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);"><font face="宋体" style="font-size: 12pt;">默认的构造见模板类中</font></span></div><div><span style="color: rgb(51, 51, 51);"><font face="宋体" style="font-size: 12pt;">基于复制的构造方法：</font></span></div></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;析构：释放空间。</font></div><div><font face="宋体" style="font-size: 12pt;">循秩访问的实现：重载向量操作符[]；</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">置乱算法：该算法从待置乱区间的末元素开始， 逆序地向前逐一处理各元素。 如图2.2(a)所示， 对每一个当前元素V[i - 1]， 先通过调用rand()函数在[0, i)之间等概率地随机选取一个元素， 再令二者互换位置；</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">插入操作的实现：扩容，自后向前移动单元(O(1)&nbsp;~O(n))；</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">区间删除：自前向后移动，缩容；</font></div><div><font face="宋体" style="font-size: 12pt;">单元素删除：调用区间删除算法，为什么不通过单元素来实现区间删除(效率不高)；(复杂度O(1)&nbsp;~O(_size))；</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">查找:从末元素起自后向前，逐一取出各个元素并与目标元素e进行比对，直至发现与之相等者（查找成功），或者直至检查过所有元素之后仍未找到相等者（查找失败）。(复杂度O(1)&nbsp;~O(n))；</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 比对 ：判断两个对象是否相等；比较：判断两个对象的相对大小。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;其一， 将比对操作和比较操作分别封装成通用的判等器和比较器。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp;&nbsp; 其二，在定义对应的数据类型时，通过重载&quot;&lt;&quot;和&quot;==&quot;之类的操作符，给出大小和相等关系的具体定义及其 &nbsp; 判别方法</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无序(仅只支持比对操作，但未必支持比较操作)，有序(肯定支持比较操作)。</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;输入敏感：对于规模相同、内部组成不同的输入，渐进运行时间却有本质区别。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">唯一化：该算法自前向后逐一考查各元素_elem[i]，并通过调用find()接口， 在其前缀中寻找与之雷同者。(正确性的证明(不变性与单调性)，复杂度O(n <span style="vertical-align: super;">2</span> )(如何改善))；</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">遍历：</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div></div><div style="min-height: 21pt;"><span style="min-height: 21pt; font-weight: bold;"><font face="宋体" style="font-size: 12pt;">有序向量</font></span></div><div style="min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">有序性的判断：比较相邻元素是否有序。 可以比较实现对别的接口算法的优化</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">唯一性：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案一：可以自前向后地逐一检查各对相邻元素： 若二者雷同则调用remove()接口删除靠后者，否则转向下一对相邻元素(效率为O(n <span style="vertical-align: super;">2</span> )，比较低)</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案二：既然各组重复元素必然彼此相邻地构成一个子区间， 故只需依次保留各区间的起始元素。 于是，这里引入了变量i和j。 每经过若干次移动， i和j都将分别指向下一对相邻子区间的首元素；在将后者转移至前者的后继位置之后(效率为O(n)，比较高)</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;对比：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方案一中复杂度比较高的根源为，在方案一中在对remove()接口的各次调用中，同一元素可能作为后继元素向前移动多次，且每次仅移动一个单元。而在方案中将相同元素进行批量删除。</font></div></div><div style="min-height: 18pt;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">查找：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分查找（A）：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法以中点mi = (lo + hi) / 2为界，将其大致平均地分前、后两个子向量。随后通过一至两次比较操作，确定问题转化的方向。通过快捷的整数移位操作回避了相对更加耗时的除法运算 .( 成功查找长度为O(1.5&nbsp;*log <span style="vertical-align: sub;">2</span> n)，失败查找长度为O(1.5&nbsp;*log <span style="vertical-align: sub;">2</span> n) )。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 19pt;"><div><font face="宋体" style="font-size: 12pt;">Fibonacci查找 :</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以黄金分割点取代中点作为切分点，从而调整前、后区域的宽度，适当地加长（缩短）前（后）子向量 ( 复杂度为O(1. 44 * log <span style="vertical-align: sub;">2</span> n) ) 。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 19pt;"><div><font face="宋体" style="font-size: 12pt;">二分查找（ B ）：</font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一步迭代只需判断是否e &lt; A[mi]，将e &lt; A[mi]归纳为后一种情况，并且可相应地更新有效查找区间的右边界（ hi = mi）或左边界（ lo = mi , 在 A 版本中为lo = mi+1）。通过这样的方法统一沿两个方向深入所需要执行的比较次数为一次。另外，在该版本中只有等到区间的宽度已不足2个单元时迭代才会终止，最后再通过一次比对判断查找是否成功(复杂度为O(logn))。</font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法的最好情况下的效率有所倒退。当然，作为补偿，最坏情况下的效率相应地有所提高。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 19pt;"><div><font face="宋体" style="font-size: 12pt;">二分查找（ C ）：</font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp;&nbsp; 首先，只有当有效区间的宽度缩短至0（而不是1）时，查找方告终止。另外，在每次转入后端分支时，子向量的左边界取作mi + 1而不是mi。改进只能确定切分点A[mi] &lt; =e， “ 贸然” 地将A[mi]排除在进一步的查找范围之外，似乎可能因遗漏这些元素，而导致本应成功的查找以失败告终(正确性的证明)。</font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 19pt;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;">插值查找：</font></div><div><font face="宋体" style="font-size: 12pt;">(最坏：O(n)；平均：每经一次比较，待查找区间宽度N缩根号2，故O（log log N),但从O（log N）到O（log log N），不值得！！(除非查找区间特别大，反正优势不明显，易受小扰动的干扰与蒙骗，需引入乘法或者除法)</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">对比：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在A版本的二分查找，即便是迭代次数相同的情况，对应的查找长度也不尽相等。究其根源在于，在每一步迭代中为确定左、右分支方向，分别需要做1次或2次元素比较， 从而造成不同情况所对应查找长度的不均衡&nbsp;。Fibonacci查找是通过将调整前、后区域的宽度，适当地加长（缩短）前（后）子向量来改善A版本的不足，</font></div><div><font face="宋体" style="font-size: 12pt;">B版本的二分查找通过 统一沿两个方向深入所需要执行的比较次数，比如都统一为一次来改善A版本的不足 ，对算法返回的具有一定的约定性(总是返回不大于查找元素的最后一个元素)，从而实现接口的统一化。与二分查找相比，插值查找为在字长意义上的折半查找，二分查找为在字长意义上的顺序查找。</font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 17pt;"><span style="text-indent: 0mm; min-height: 17pt;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></span></div><div style="min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">排序：</font></div></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">起泡排序：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 依次比较各对相邻元素， 每当发现逆序即令二者彼此交换；一旦经过某趟扫描之后未发现任何逆序的相邻元素， 即意味着排序任务已经完成， 则通过返回标志“ sorted” ， 以便主算法及时终止。(O(N平方))</font></div></div><div style="margin-left: 19mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 18pt;"><span style="text-indent: 0mm; min-height: 18pt;"><font face="宋体" style="font-size: 12pt;">改进一：</font></span></div><div style="margin-left: 19mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;">改进二： &nbsp;</font></div><div><font face="宋体" style="font-size: 12pt;">稳定性：</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 归并排序：(分治策略)</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;与起泡排序通过反复调用单趟扫描交换类似，归并排序也可以理解为是通过反复调用所谓二路归并（ 2-way merge） 算法而实现的二路归并，就是将两个有序序列合并成为一个有序序列。(O（nlogn ）)&nbsp;</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;主体思想：将向量S[lo, hi)转换为有序向量，可以均匀地将其划分为两个子向量：S[lo, mi)S[mi, hi)以下，只要通过递归调用将二者分别转换为有序向量，即可借助以上的二路归并算法，得到与原向量S对应的整个有序向量。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp;&nbsp; 递归实现：上半部分对应于递归的不断深入过程：不断地均匀划分（子）向量， 直到其规模缩减至1从而抵达递归基。此后如图中下半部分所示， 开始递归返回。 通过反复调用二路归并算法，相邻且等长的子向量不断地捉对合并为规模更大的有序向量，直至最终得到整个有序向量。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;二路归并：二路归并属于迭代式算法。每步迭代中，只需比较两个待归并向量的首元素，将小者取出并追加到输出向量的末尾， 该元素在原向量中的后继则成为新的首元素。 如此往复，直到某一向量为空。最后，将另一非空的向量整体接至输出向量的末尾。（小于O（N），该时间复杂度与排序算法时间不少于O（nlogn）不矛盾，毕竟这里的输入为划分有序的两组）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 18pt;"><b>列表<font color="#1E4E79">：</font></b></font></div><div><font face="宋体" style="font-size: 12pt;"><span style="font-weight: bold;">定义：</span>要求各元素在逻辑上具有线性次序（通过指针或者引用），但对其物理地址却未作任何限制，“ 循位置访问”（ call-by-position）。</font></div><div><font face="宋体" style="font-size: 12pt;">列表节点 ：列表是链表结构的一般化推广， 其中的元素称作节点（ node） ， 分别由特定的位置或链接指代。</font></div><ol><li><div><font face="宋体" style="font-size: 12pt;">数据结构支持接口支持的操作,通常无非静态和动态两类:前者仅从中获取信息，该操作仅读取，不改变数据结构的内容与组成(元素读取，查找) ,后者则会修改数据结构的局部甚至整体(如插入，移除) 。</font></div></li><li><div><font face="宋体" style="font-size: 12pt;">数据结构支持的存储策略也是静态和动态两种。其中向量采用静态储存的存储结构，该数据结构中元素访问方式主要为循秩访问，物理储存地址与逻辑次序线性对应，其静态操作性能较好，其中列表采用动态储存的存储结构 ，该数据结构中元素访问方式主要为循位置访问，物理储存地址与逻辑次序无关&nbsp;，其动态操作性能较好。</font></div></li></ol><div><span style="font-weight: bold;"><font face="宋体" style="font-size: 12pt;">接口与实现</font></span></div><div><font face="宋体" style="font-size: 12pt;">列表节点：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;接口：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <en-media hash="5cfbfd06b5c87b9717e2cceb3a328932" style="height: auto;" type="image/png" width="739"/></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode模板类：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;列表</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp;&nbsp; 接口：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<en-media hash="65354ba3742fe888bca0c8e4936fdc99" style="height: auto;" type="image/png" width="769"/></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;ListNode模板类：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="text-align: justify;"><font face="宋体" style="font-size: 12pt;"><span style="font-weight: bold;">常规</span><span style="font-weight: bold;">列</span><span style="font-weight: bold;">表的基本操作</span></font></div><div><font face="宋体" style="font-size: 12pt;">对外部可见的数据节点如果存在，则其中的第一个和最后一个节点分别称作首节点（ first node） 和末节点（ last node）.头节点紧邻于首节点之前， 尾节点紧邻于末节点之后。这类经封装之后从外部不可见的节点， 称作哨兵节点（ sentinel node）.</font></div><div><font face="宋体" style="font-size: 12pt;">构造与析构：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造：默认构造方法与基于复制的构造方法（复制的实现：复制为长度的两倍）;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;析构：释放空间。删除header的后继。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">位置按秩：重载向量操作符[]；（效率太低O（n））</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">查找算法:从节点P开始不断沿着前驱不断与查找数据对比（参数N，P的语义，时间复杂度为O（n））</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">插入算法:该算法首先所示创建新节点new，构造函数同时将其数据项置为e，并令其后继链接succ指向当前节点，令其前驱链接pred指向当前节点的前驱节点。，使new成为当前节点前驱节点的后继，使new成为当前节点的前驱(次序不能颠倒，复杂度比较低为O（1），微创，还后插入，首插入，尾插入)</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">删除:&nbsp;为了删除位置p处的节点，令其前驱节点与后继节点相互链接。&nbsp;释放掉已经孤立出来的节点p，同时相应地更新列表规模计数器_size。（复杂度比较低为O（1），微创）</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">唯一化:这里也是自前向后依次处理各节点p， 一旦通过find()接口在p的前驱中查到雷同者，则随即调用remove()接口将其删除。（正确性的证明，复杂度为O（N平方））</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><span style="font-weight: bold;">有序</span><span style="font-weight: bold;">列</span><span style="font-weight: bold;">表:</span></font></div><div><font face="宋体" style="font-size: 12pt;">唯一化: 位置指针p和q分别指向每一对相邻的节点， 若二者雷同则删除q，否则转向下一对相邻节点。如此反复迭代，直至检查过所有节点（时间复杂度为O（n） ）。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">查找:与无序列表差不多，其原因为：列表为循位置访问 （ 最好情况下的运行时间为O(1)， 最坏情况下为O(n)。 在等概率的前提下，平均运行时间也是O(n)，线性正比于查找区间的宽）</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;RAM：循RANK访问，图灵机模型：循位置访问</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">排序：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">插入排序： 始终将整个序列视作并切分为两部分：有序的前缀，无序的后缀；通过迭代，反复地将后缀的首元素转移至前缀中 （O（n）~O（n平方），&nbsp;vector&nbsp;与list一样适合）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">选择排序：该算法也将序列划分为无序前缀和有序后缀两部分；此外，还要求前缀不大于后后缀。如此，每次只需从前缀中选出最大者，并作为最小元素转移至后缀中，即可使有序部分的范围不断扩张。（最好，最坏都是O（n平方），vector&nbsp;与list一样适合，起泡就是一个选择排序）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 归并排序：(分治策略)同vector。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体"><font style="font-size: 18pt;"><b>栈与队列</b></font><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font></div><div><font face="宋体" style="font-size: 12pt;">相对于一般的序列结构，栈与队列的数据操作范围仅限于逻辑上的特定某端栈接口以及实现， 栈与队列的外部接口更为简化和紧凑，故亦可视作向量与列表的特例</font></div><div><span style="color: rgb(255, 0, 0);"><font face="宋体" style="font-size: 12pt;">基本概念：</font></span></div><div><font face="宋体" style="font-size: 12pt;">定义：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈（ stack） 是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，故也可定义首、末元素。不过，尽管栈结构也支持对象的插入和删除操作，但其操作的范围仅限于栈的某一特定端。禁止操作的另一端，称作盲端，后进先出。</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列（ queue） 也是存放数据对象的一种容器，其中的数据对象也按线性的逻辑次序排列。队列结构同样支持对象的插入和删除，但两种操作的范围分别被限制于队列的两端。先进先出</font></div><div><span style="color: rgb(255, 70, 53);"><font face="宋体" style="font-size: 12pt;">栈的实现：</font></span></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack模板类： 将栈作为向量的派生类， 即可利用C++的继承机制，设计了包括入栈，出栈，取顶操作， 时间复杂度均为常数</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><span style="color: rgb(255, 0, 0);">调用栈</span><span style="color: rgb(255, 0, 0);">：</span></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Windows等大部分操作系统中，每个运行中的二进制程序都配有一个调用栈（ call&nbsp;stack） 或执行栈（ execution stack）</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数调用的实现：调用栈的基本单位是帧（ frame） 。每次函数调用时，都会相应地创建一帧，记录该函数实例在二进制程序中的返回地址（ return address） ，以及局部变量、传入参数等，并将该帧压入调用栈.</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过栈实现递归:在递归的过程中，后台隐式地维护调用栈的过程中，难以区分哪些参数和变量是对计算过程有实质作用的，更无法以通用的方式对它们进行优化，因此不得不将描述调用现场的所有参数和变量悉数入栈。再加上每一帧都必须保存的执行返回地址以及前一帧起始位置，往往导致程序的空间效率不高甚至极低；同时，隐式的入栈和出栈操作也会令实际的运行时间增加不少。故应该避免递归，使用迭代来替代递归，实现显示的维护一个调用栈。</font></div><div><span style="color: rgb(255, 70, 53);"><font face="宋体" style="font-size: 12pt;">栈应用：</font></span></div><div><font face="宋体" style="font-size: 12pt;">4：栈式计算</font></div><div><font face="宋体" style="font-size: 12pt;">1:逆序输出问题：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题描述：首先，虽有明确的算法，但其解答却以线性序列的形式给出；其次，无论是递归还是迭代实现， 该序列都是依逆序计算输出的；最后，输入和输出规模不确定，难以事先确定盛放输出数据的容器大小。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题实例：进制转化（任给十进制整数n，将其转换为进制的表示形式）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">实例实现（递归）：新进制下的各数位须按由低到高次序逐位算出，但只要引入一个栈并将算得的数位依次入栈，则在计算结束后只需通过反复的出栈操作即可由高到低地将其顺序输出。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">实例实现(迭代)：将递归转换为循环。避免参数的保存，提高空间效率</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;">2:递归嵌套问题</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题描述：具有自相似性的问题多可嵌套地递归描述，但因分支位置和嵌套深度并不固定，其递归算法的复杂度不易控制</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题实例：括号匹配（表达式括号匹配的检查则又是语法检查中必需的一个环节，包括小括号，中括号，花括号，大括号等）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">实例实现（递归）：将表达式划分为子表达式S0、 S1和S2，分别递归地判断S1和S2是否匹配，O(n2)时间(分而自治)</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">实例实现(迭代)：凡遇到左括号，无论属于哪类均统一压入栈S中。若遇右括号，则弹出栈顶的左括号并与之比对。 若二者属于同类，则继续检查下一字符； 否则，即可断定表达式不匹配。 推广至多类括号并存。（如果使用迭代器则不行）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题实例： 栈混洗问题（考查三个栈A、 B和S，其中A含有n个元素，自顶而下构成输入序列，B和S初始为空。若只允许通过S.push(A.pop())弹出栈A的顶元素并压入栈S中，或通过B.push(S.pop())弹出S的顶元素并压入栈B中，则在经过一系列这样的操作后，当栈A和S均为空时，原A中的元素应均已转入栈B， 该序列称作原输入序列的一个栈混洗（如何判断栈混洗（三种算法）：直接使用栈来模拟栈混洗 O(n)，栈混洗有多少序行的判断））</font></div><div><font face="宋体" style="font-size: 12pt;">3:延迟缓冲问题</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题描述：输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后， 才能作出判断并实施计算</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 问题实例：常规表达式（中缀表达式）求值（字符串与对应数值的交替转换的过程）</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">算法原理（主算法）：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将尾哨兵作为头哨兵首先入栈，在运算符栈非空之前，逐个处理表达式中各字符，直到对操作数以及运算符进行读取，遇到操作数与运算符， 将分别缓冲至栈opnd和栈optr。并且判断当前运算符的优先级，并且对不同优先级执行不同的处理。 &nbsp; &nbsp;</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">优先级表的实现：二维表格定义优先级。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;左括号都是小于或者等于，右括号都是大于或者等于,/0中看行都小于看列都大于，！看行都是大于。（行 当前运算符，列是栈顶运算符），对角线几乎都是小于</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">不同优先级的处理 ：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp;&nbsp; 1） 若当前运算符的优先级更高，则optr中的栈顶运算符尚不能执行；2）反之，一旦栈顶运算符的优先级更高，则可以立即弹出并执行对应的运算3）当前运算符与栈顶运算符的优先级“相等”。 脱括号幵接收下一个字符。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><en-media hash="a3ff3b4ab98ce6e664b37076b342af85" type="image/png"/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;">4.栈计算问题：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题描述：基于栈结构的特定计算模式。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">问题实例：逆波兰表达式(后缀表达式，RPN )（定义：操作符紧邻于对应的（最后一个） 操作数之后。 比如“ 1 2 +” 即通常习惯的“ 1 + 2”，可以不判断优先级）的求值与转换问题</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">逆波兰表达式求值：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入栈S，用以存放操作数;在运算符栈非空之前，逐个处理表达式中各字符，遇到操作数，遇到操作符则从栈S中弹出运算符x所需数目的操作数;对弹出的操作数试试运算，并且将运算结结果重新压入S。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">常规表达式与逆波兰表达式的转换算法：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 手工转换：首先，添加括号，其次移动运算符，最后去除括号</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 算法实现：常规表达式的求值类似。（算法处理后面，操作数的顺序不会发生改变，运算符可以会变化）</font></div><div><span style="color: rgb(255, 0, 0);"><font face="宋体" style="font-size: 12pt;">队列的实现：</font></span></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;Queue模板类：将队列作为列表的派生类， 即可利用C++的继承机制，设计了包括元素统计，是否为空，插入队尾，删除首对象，引用首对象 ，时间复杂度均为常数。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 18pt;"><b>树</b></font></div><div><span style="color: rgb(255, 0, 0);"><font face="宋体" style="font-size: 12pt;">树的基本概念：</font></span></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特征：2维list，有线性特征 ，但是不是线性结构，有层次，也是一种特殊的图。</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要提出树：无论是vector和list都无法兼顾静态操作和动态操作</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(186, 0, 255);">树</span>也由一组顶点（vertex，每一个顶点都是以节点在计算机中存在 ）以及联接与其间的若干条边（edge）组成。往往还会在此基础上，再指定某一特定顶点，并称之为<span style="color: rgb(158, 0, 243);">根</span>（ root） 。在指定根节点之后，我们也称之为<span style="color: rgb(209, 0, 255);">有根树</span>（ rooted tree）。有序树</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任一节点v在通往树根沿途所经过的每个节点都是其<span style="color: rgb(186, 0, 255);">祖先</span>（ ancestor） ， v是它们的<span style="color: rgb(186, 0, 255);">后代</span>（ descendant）。特别地， v的祖先/后代包括其本身， 而v本身以外的祖先/后代称作真祖先（ proper ancestor） /真后代（ proper&nbsp;descendant）。若节点u是v的祖先且恰好比v高出一层，则称u是v的<span style="color: rgb(186, 0, 255);">父亲</span>（parent）v是u的<span style="color: rgb(186, 0, 255);">孩子</span>（child）。v的孩子总数，称作其<span style="color: rgb(186, 0, 255);">度数或度</span>，无孩子的节点称作<span style="color: rgb(186, 0, 255);">叶节点</span>（ leaf），v所有的后代及其之间的联边称作<span style="color: rgb(186, 0, 255);">子树</span></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;沿每个节点v到根r的唯一通路所经过边的数目，称作v的<span style="color: rgb(186, 0, 255);">深度</span>（ depth） ，记作depth(v)。依据深度排序，可对所有节点做<span style="color: rgb(186, 0, 255);">分层归类（层次）。</span>在半线性中，祖先如果存在那必然唯一，但后代不一定唯一。</font></div><div><font face="宋体" style="font-size: 12pt;"><span style="color: rgb(186, 0, 255);">&nbsp; &nbsp;</span> &nbsp;树T中所有节点深度的最大值称作该树的<span style="color: rgb(186, 0, 255);">高度</span>（ height），空树的高度为-1。</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; &nbsp;V中的k+1个节点，通过E的k条边依次连接，构成一条<span style="color: rgb(186, 0, 255);">路径</span>，<span style="color: rgb(186, 0, 255);">路径的长度为路径的边数</span>，如果路径的首末节点相同，则是<span style="color: rgb(186, 0, 255);">环路</span>。节点之间都有路径则称为<span style="color: rgb(186, 0, 255);">连通图</span>，如果没有环路则称为<span style="color: rgb(186, 0, 255);">无环图</span>。<span style="color: rgb(186, 0, 255);">树就是无环连通图</span>，极小连通图，极大无环图，故任一节点与根存在唯一路径（长度），可对所有节点进行等价类划分。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><span style="color: rgb(255, 0, 0);"><font face="宋体" style="font-size: 12pt;">树的逻辑表示：</font></span></div><div><font face="宋体" style="font-size: 12pt;">接口：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><en-media hash="e7401649e5f15df38a70ae715337b925" style="height: auto;" type="image/png"/></font></div><div><font face="宋体" style="font-size: 12pt;">父节点实现：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（node） 外，还需要保存父节点</font></div><div><font face="宋体" style="font-size: 12pt;">（ parent） 的秩或位置。 可为树根指定一个虚构的父节点-1或NULL，以便统一判断。（空间性能0（N），时间性能：parent() O(1),root() O(1)/O(n),firstchild() O(n) ,nextsibling() &nbsp;O(n)）</font></div><div><font face="宋体" style="font-size: 12pt;">孩子节点实现：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp;&nbsp; 令各节点将其所有的孩子组织为一个向量或列表（向下查找的性能不足）</font></div><div><font face="宋体" style="font-size: 12pt;">父节点+孩子节点实现：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把上面两点都结合起来（孩纸节点的规模不同）</font></div><div><font face="宋体" style="font-size: 12pt;">长子+兄弟实现：</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">有序多叉树中任一非叶节点都有唯一的“ 长子” ，而且从该“ 长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。为每个节点设置两个指针，分别指向其“长子”和下一“兄弟”。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><span style="color: rgb(255, 0, 0);"><font face="宋体" style="font-size: 12pt;">二叉树的相关概念：</font></span></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">定义：节点度树不超过2的树称为二叉树，其宽度是高度的指数次幂，故算法设计的时候应该尽量选择长宽，不长高。如果每一个节点的出处都是偶数，该树称为真二叉树。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">在有根性和有序性的前提下，二叉树可以描述所有的树，通过长子兄弟法可以将所有的有根有序树转换为二叉树。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><span style="color: rgb(255, 0, 0);"><font face="宋体" style="font-size: 12pt;">二叉树的实现：</font></span></div><div><font face="宋体" style="font-size: 12pt;"><en-media hash="2a396d98efdd5b14cb825aabaee9b4ed" type="image/png"/></font></div><div><font face="宋体" style="font-size: 12pt;">二叉树节点模板类：</font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个二叉树 节点都是通过引用来访问别的节点，别的节点也是通过别的节点访问该节点。在该模板类中主要实现左插（O（1））右插（O（1））计数（sizeO（n）, 遍历等操作。</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">二叉树模板类:</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">高度更新：在每一节点v处，只需读出其左、右孩子的高度并取二者之间的大者，再计入当前节点本身，就得到了v的新高度(单个节点高度更新（O（1））。通常，接下来还需要从v出发沿parent指针逆行向上，依次更新各代祖先的高度记录，（历代节点高度更新:O（n）)。(或者改为一旦有节点加入或离开二叉树，则更新其所有祖先的高度)</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">节点插入：更新树的规模，调用二叉树节点模板类中的插入操作，更新高度。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">子树接入：首先将待植入的二叉树S的根节点作为x的右孩子，同时令x作为该根节点的父亲；然后，更新全树规模以及节点x所有祖先的高度；最后，将树S中除已接入的各节点之外的其余部分归还系统。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">子树删除：与接入的方法相反。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">子树分离：与删除的基本一致，不过对于分离的子树需要进一步封装。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">这些操作都是常数时间。</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><span style="color: rgb(255, 0, 0);">二叉树的遍历</span><span style="color: rgb(255, 0, 0);">：</span></font></div><div><font face="宋体" style="font-size: 12pt;">按照事先约定的某种规则或次序，对节点各访问一次而且仅一次。</font></div><div><font face="宋体" style="font-size: 12pt;">先序遍历：VLR</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">递归实现：为遍历（子）树x，首先核对x是否为空。若x为空，则直接退出。其效果相当于递归基。反之，若x非空，则按照先序遍历关于局部次序的定义，优先访问其根节点x； 然后，依次深入左子树和右子树， 递归地进行遍历（O（n））</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">迭代实现1（上述递归是一个尾递归，<span style="color: rgb(186, 0, 255);">可以通过二分递归到迭代+单递归到迭代+栈 转换为迭代，该方法只适合尾递归</span>)：建立辅助栈，将跟节点入栈，在栈变空之前反复扫描，不断的弹出和访问当前节点，并且该节点的右孩子压入栈中，然后在压左孩子。(正确性：无遗失，根先，左先右后，O（1）)</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">迭代实现1（推广到非尾递归）：先序遍历序列可分解为两段： 沿最左侧通路自顶而下访问的各节点， 以及自底而上遍历的对应右子树。在全树以及其中每一棵子树的根节点处，该算法都首先调用函数VisitAlongLeftBranch()，自顶而下访问最左侧通路沿途的各个节点。这里也使用了一个辅助栈，逆序记录最左侧通路上的节点，以便确定其对应右子树自底而上的遍历次序</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">非线性</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">中序遍历：LVR</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">递归实现:类似于先序遍历</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">后序遍历：LRV</font></div><div style="margin-left: 40px;"><font face="宋体" style="font-size: 12pt;">递归实现:类似于中序遍历</font></div><div><font face="宋体" style="font-size: 12pt;">层次遍历：</font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">重构</font></div><div><font style="font-family: 宋体; font-size: 18pt;"><b>图</b></font></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal; line-height: 33px;"><font face="宋体" style="font-size: 12pt;">概念：</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">实现：</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 接口：</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 邻接矩阵+关联矩阵：带权图，有向图存在一定冗余性</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 顶点与边的实现：</font></span></div><div><font face="宋体" style="font-size: 12pt;"><span style="color: rgb(100, 100, 100); font-variant-caps: normal; font-variant-ligatures: normal;">&nbsp; &nbsp;</span> <span style="font-variant-caps: normal; font-variant-ligatures: normal;">邻接矩阵的实现：二维vector</span></font></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 顶点的静态操作：O(n);</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 边的操作：</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 顶点的动态操作：</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp; &nbsp; 综合评价：平面图</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">广度优先搜索：</font></span></div><div><span style="font-variant-caps: normal; font-variant-ligatures: normal;"><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></span></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></div><div align="left" style="margin-right: 0mm; text-indent: 0mm; margin-top: 0mm; margin-bottom: 0mm; min-height: 18pt;"><div><font face="宋体" style="font-size: 12pt;"><br/></font></div><div><font face="宋体" style="font-size: 12pt;"><br/></font></div></div></div><div><br/></div>